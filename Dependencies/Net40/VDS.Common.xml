<?xml version="1.0"?>
<doc>
    <assembly>
        <name>VDS.Common</name>
    </assembly>
    <members>
        <member name="T:VDS.Common.Collections.AbstractListBackedBoundedList`1">
            <summary>
            Abstract implementation of a bounded list backed by a standard <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
            <typeparam name="T">Element type</typeparam>
        </member>
        <member name="T:VDS.Common.Collections.IBoundedList`1">
            <summary>
            Interface for bounded lists which are extensions to the standard list contract with some additional constraints
            </summary>
            <remarks>
            <para>
            The primary constraint on a bounded list is that it is guaranteed to never grow beyond it's configured maximum capacity.  Implementations may internally grow the data structures used to store the elements up to/above that limit using whatever strategy they desire but they <strong>must</strong> never allow the size of the list to grow beyond the maximum capacity.
            </para>
            <para>
            The second constraint on a bounded list is with regards to its behaviour when a user attempts to assert more elements than the list has capacity for.  The behaviour in this regard is declared via the <see cref="P:VDS.Common.Collections.IBoundedList`1.OverflowPolicy"/> property, depending on the policy declared different behaviours may occur.
            </para>
            </remarks>
            <typeparam name="T">Element type</typeparam>
        </member>
        <member name="P:VDS.Common.Collections.IBoundedList`1.OverflowPolicy">
            <summary>
            Gets the overflow policy that applies when attempting to add more elements to the list than there is capacity for
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.IBoundedList`1.MaxCapacity">
            <summary>
            Gets the maximum capacity of the bounded list i.e. the maximum number of elements it holds
            </summary>
        </member>
        <member name="F:VDS.Common.Collections.AbstractListBackedBoundedList`1._list">
            <summary>
            Underlying list
            </summary>
        </member>
        <member name="M:VDS.Common.Collections.AbstractListBackedBoundedList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Creates a new list backed bounded list using the given list
            </summary>
            <param name="list">List</param>
        </member>
        <member name="M:VDS.Common.Collections.AbstractListBackedBoundedList`1.SelectInitialCapacity(System.Int32)">
            <summary>
            Helper method for selecting an initial capacity for the backing list to avoid preemptively allocating the full capacity needed to hold the maximum number of permitted elements
            </summary>
            <param name="capacity">MaxCapacity</param>
            <returns>Initial capacity</returns>
        </member>
        <member name="M:VDS.Common.Collections.AbstractListBackedBoundedList`1.IndexOf(`0)">
            <summary>
            Gets the index of the given item
            </summary>
            <param name="item">Item</param>
            <returns>Index or -1 if not in list</returns>
        </member>
        <member name="M:VDS.Common.Collections.AbstractListBackedBoundedList`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an item at the given index
            </summary>
            <param name="index">Index</param>
            <param name="item">Item</param>
        </member>
        <member name="M:VDS.Common.Collections.AbstractListBackedBoundedList`1.Add(`0)">
            <summary>
            Adds an item
            </summary>
            <param name="item">Item</param>
        </member>
        <member name="M:VDS.Common.Collections.AbstractListBackedBoundedList`1.Clear">
            <summary>
            Clears the list
            </summary>
        </member>
        <member name="M:VDS.Common.Collections.AbstractListBackedBoundedList`1.Contains(`0)">
            <summary>
            Gets whether the list contains the given item
            </summary>
            <param name="item">Item</param>
            <returns>True if contained in the list, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Collections.AbstractListBackedBoundedList`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the list to the given array
            </summary>
            <param name="array">Array</param>
            <param name="arrayIndex">Array Index to start the copy at</param>
        </member>
        <member name="M:VDS.Common.Collections.AbstractListBackedBoundedList`1.Remove(`0)">
            <summary>
            Removes an item from the list
            </summary>
            <param name="item">Item</param>
            <returns>True if item was removed, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Collections.AbstractListBackedBoundedList`1.GetEnumerator">
            <summary>
            Gets an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Collections.AbstractListBackedBoundedList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Collections.AbstractListBackedBoundedList`1.RemoveAt(System.Int32)">
            <summary>
            Removes an item at the given index
            </summary>
            <param name="index">Index</param>
        </member>
        <member name="P:VDS.Common.Collections.AbstractListBackedBoundedList`1.Count">
            <summary>
            Gets the size of the list
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.AbstractListBackedBoundedList`1.IsReadOnly">
            <summary>
            Gets whether the list is ready only
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.AbstractListBackedBoundedList`1.Item(System.Int32)">
            <summary>
            Gets/Sets the value at the given index
            </summary>
            <param name="index">Index</param>
            <returns>Value</returns>
        </member>
        <member name="P:VDS.Common.Collections.AbstractListBackedBoundedList`1.OverflowPolicy">
            <summary>
            Gets the overflow policy that is in-use
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.AbstractListBackedBoundedList`1.MaxCapacity">
            <summary>
            Gets the maximum capacity of the list
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.BinarySparseArray`1">
            <summary>
            A sparse array implementation backed by a binary tree
            </summary>
            <remarks>
            This implementation provides a trade off between look up time and memory usage and so provides a compromise between the <see cref="T:VDS.Common.Collections.BlockSparseArray`1"/> and <see cref="T:VDS.Common.Collections.LinkedSparseArray`1"/>
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:VDS.Common.Collections.ISparseArray`1">
            <summary>
            Interface for sparse arrays which are memory efficient implementations of arrays
            </summary>
            <typeparam name="T">Value type</typeparam>
        </member>
        <member name="M:VDS.Common.Collections.ISparseArray`1.Clear">
            <summary>
            Clears the array i.e. resets all values to the default and frees any unecessary storage
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.ISparseArray`1.Item(System.Int32)">
            <summary>
            Gets/Sets the element at the specified index
            </summary>
            <param name="index">Index</param>
            <returns>Element at the given index</returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if the given index is out of range</exception>
        </member>
        <member name="P:VDS.Common.Collections.ISparseArray`1.Length">
            <summary>
            Gets the length of the array
            </summary>
        </member>
        <member name="M:VDS.Common.Collections.BinarySparseArray`1.#ctor(System.Int32)">
            <summary>
            Creates a new sparse array
            </summary>
            <param name="length">Length</param>
        </member>
        <member name="M:VDS.Common.Collections.BinarySparseArray`1.GetEnumerator">
            <summary>
            Gets an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Collections.BinarySparseArray`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Collections.BinarySparseArray`1.Clear">
            <summary>
            Clears the array
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.BinarySparseArray`1.Item(System.Int32)">
            <summary>
            Gets/Sets the value at a given index
            </summary>
            <param name="index">Index</param>
            <returns>Value</returns>
        </member>
        <member name="P:VDS.Common.Collections.BinarySparseArray`1.Length">
            <summary>
            Gets the length of the array
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.BlockSparseArray`1">
            <summary>
            A memory efficient sparse array implemented as a sequence of blocks
            </summary>
            <remarks>
            <para>
            This sparse array is implemented as a series of potentially empty blocks such that only blocks which contain values have any memory allocated to them.  This means it is extremely memory efficient for sparsely populated arrays.  The block size may be tweaked to limit the amount of memory that might be newly allocated by setting a value since setting a value in an as yet unpopulated block requires allocating the memory for that block.  Since at minimum the sequence of blocks must be maintained this implementation can be less memory efficient than the <see cref="T:VDS.Common.Collections.LinkedSparseArray`1"/> for some usages.
            </para>
            <para>
            Since the sequence of blocks and the contents of each block are implemented using standard arrays an element may be accessed by index in linear time regardless of how empty/full the sparse array is.
            </para>
            </remarks>
            <typeparam name="T">Value type</typeparam>
        </member>
        <member name="F:VDS.Common.Collections.BlockSparseArray`1.DefaultBlockSize">
            <summary>
            Default block size used if one is not explicitly specified
            </summary>
        </member>
        <member name="M:VDS.Common.Collections.BlockSparseArray`1.#ctor(System.Int32)">
            <summary>
            Creates a new sparse array with the default block size
            </summary>
            <param name="length">Length of the array</param>
        </member>
        <member name="M:VDS.Common.Collections.BlockSparseArray`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new sparse array
            </summary>
            <param name="length">Length</param>
            <param name="blockSize">Block Size</param>
        </member>
        <member name="M:VDS.Common.Collections.BlockSparseArray`1.GetEnumerator">
            <summary>
            Gets an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Collections.BlockSparseArray`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Collections.BlockSparseArray`1.Clear">
            <summary>
            Clears the array
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.BlockSparseArray`1.Item(System.Int32)">
            <summary>
            Gets/Sets the value at the given index
            </summary>
            <param name="index">Index</param>
            <returns>Value</returns>
        </member>
        <member name="P:VDS.Common.Collections.BlockSparseArray`1.BlockSize">
            <summary>
            Gets/Sets the block size
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.BlockSparseArray`1.Length">
            <summary>
            Gets the length of the array
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.CappedBoundedList`1">
            <summary>
            A simple bounded list implementation that errors if users attempt to add more items than there is capacity for
            </summary>
            <typeparam name="T">Element type</typeparam>
        </member>
        <member name="M:VDS.Common.Collections.CappedBoundedList`1.#ctor(System.Int32)">
            <summary>
            Creates a new bounded list with the given capacity
            </summary>
            <param name="capacity">MaxCapacity</param>
        </member>
        <member name="M:VDS.Common.Collections.CappedBoundedList`1.#ctor(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new bounded list with the given capacity and items
            </summary>
            <param name="capacity">MaxCapacity</param>
            <param name="items">Items</param>
            <remarks>
            If the number of items provided exceeds the declared capacity then an error will be thrown from the constructor
            </remarks>
        </member>
        <member name="M:VDS.Common.Collections.CappedBoundedList`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an item into the list at the given index
            </summary>
            <param name="index">Index</param>
            <param name="item">Item to insert</param>
        </member>
        <member name="M:VDS.Common.Collections.CappedBoundedList`1.Add(`0)">
            <summary>
            Adds an item to the list
            </summary>
            <param name="item">Item</param>
        </member>
        <member name="P:VDS.Common.Collections.CappedBoundedList`1.OverflowPolicy">
            <summary>
            Gets the overflow policy for this bounded list which is <see cref="F:VDS.Common.Collections.BoundedListOverflowPolicy.Error"/>
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.CappedBoundedList`1.MaxCapacity">
            <summary>
            Gets the maximum capacity of the list
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.BoundedListOverflowPolicy">
            <summary>
            Possible overflow policies for bounded lists
            </summary>
        </member>
        <member name="F:VDS.Common.Collections.BoundedListOverflowPolicy.Error">
            <summary>
            When this policy is used attempting to add more items to a bounded list than there is capacity for <strong>must</strong> result in an <see cref="T:System.InvalidOperationException"/>
            </summary>
        </member>
        <member name="F:VDS.Common.Collections.BoundedListOverflowPolicy.Discard">
            <summary>
            When this policy is used attempting to add more items to a bounded list than there is capacity for <strong>must</strong> result in the excess items being silenty discarded.  When attempting to insert items then the behaviour will depend on where you are inserting. If inserting prior to the end of the list then inserting should cause items at the end of the list to be discarded if the capacity would be exceeded.  If inserting at the end of a list that is at capacity then the item to be inserted is itself discarded.
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.DiscardingBoundedList`1">
            <summary>
            A simple bounded list implementation that discards items that would exceed the lists capacity
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="M:VDS.Common.Collections.DiscardingBoundedList`1.#ctor(System.Int32)">
            <summary>
            Creates a new bounded list with the given capacity
            </summary>
            <param name="capacity">MaxCapacity</param>
        </member>
        <member name="M:VDS.Common.Collections.DiscardingBoundedList`1.#ctor(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new bounded list with the given capacity and items
            </summary>
            <param name="capacity">MaxCapacity</param>
            <param name="items">Items</param>
            <remarks>
            If the number of items provided exceeds the declared capacity then excess items are discarded
            </remarks>
        </member>
        <member name="M:VDS.Common.Collections.DiscardingBoundedList`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an item at the given index
            </summary>
            <param name="index">Index</param>
            <param name="item">Item</param>
        </member>
        <member name="M:VDS.Common.Collections.DiscardingBoundedList`1.Add(`0)">
            <summary>
            Adds an item
            </summary>
            <param name="item">Item</param>
        </member>
        <member name="P:VDS.Common.Collections.DiscardingBoundedList`1.OverflowPolicy">
            <summary>
            Gets the overflow policy for this bounded list which is <see cref="F:VDS.Common.Collections.BoundedListOverflowPolicy.Discard"/>
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.DiscardingBoundedList`1.MaxCapacity">
            <summary>
            Gets the maximum capacity of the list
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.DuplicateSortedList`1">
            <summary>
            A sorted list that supports duplicate entries
            </summary>
            <remarks>
            Note that duplicates are not stored directly so this should <strong>only</strong> be used if the user is happy to receive multiple instances of the first instance of duplicates seen
            </remarks>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="M:VDS.Common.Collections.DuplicateSortedList`1.#ctor">
            <summary>
            Creates a new list
            </summary>
        </member>
        <member name="M:VDS.Common.Collections.DuplicateSortedList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new list with the given items
            </summary>
            <param name="items">Items</param>
        </member>
        <member name="M:VDS.Common.Collections.DuplicateSortedList`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new list that uses the given comparer
            </summary>
            <param name="comparer">Comparer</param>
        </member>
        <member name="M:VDS.Common.Collections.DuplicateSortedList`1.#ctor(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new list that uses the given comparer and has the given items
            </summary>
            <param name="comparer">Comparer</param>
            <param name="items">Items</param>
        </member>
        <member name="M:VDS.Common.Collections.DuplicateSortedList`1.GetEnumerator">
            <summary>
            Gets an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Collections.DuplicateSortedList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets ane enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Collections.DuplicateSortedList`1.Add(`0)">
            <summary>
            Adds an item to the list
            </summary>
            <param name="item">Item to add</param>
        </member>
        <member name="M:VDS.Common.Collections.DuplicateSortedList`1.Clear">
            <summary>
            Clears the list
            </summary>
        </member>
        <member name="M:VDS.Common.Collections.DuplicateSortedList`1.Contains(`0)">
            <summary>
            Gets if the list contains the given item
            </summary>
            <param name="item">Item</param>
            <returns>True if contained in the list, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Collections.DuplicateSortedList`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the list to the given array
            </summary>
            <param name="array">Array</param>
            <param name="arrayIndex">Array Index to start the copy at</param>
        </member>
        <member name="M:VDS.Common.Collections.DuplicateSortedList`1.Remove(`0)">
            <summary>
            Removes an item from the list
            </summary>
            <param name="item">Item</param>
            <returns>True if item was removed, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Collections.DuplicateSortedList`1.IndexOf(`0)">
            <summary>
            Gets the index of a given item in the list
            </summary>
            <param name="item">Item</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Collections.DuplicateSortedList`1.Insert(System.Int32,`0)">
            <summary>
            Unsupported for this list
            </summary>
            <param name="index">Index</param>
            <param name="item">Item to insert</param>
        </member>
        <member name="M:VDS.Common.Collections.DuplicateSortedList`1.RemoveAt(System.Int32)">
            <summary>
            Removes the item at the given index
            </summary>
            <param name="index">Index</param>
        </member>
        <member name="P:VDS.Common.Collections.DuplicateSortedList`1.Count">
            <summary>
            Gets the number of items in the list
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.DuplicateSortedList`1.IsReadOnly">
            <summary>
            Gets whether the list is read only
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.DuplicateSortedList`1.Item(System.Int32)">
            <summary>
            Gets the value at the given index, setting the value at an index is unsupported
            </summary>
            <param name="index">Index</param>
            <returns>Value</returns>
        </member>
        <member name="T:VDS.Common.Collections.Enumerations.AbstractEqualityEnumerable`1">
            <summary>
            Abstract implementation of a wrapper enumerable that needs item equality
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="T:VDS.Common.Collections.Enumerations.AbstractWrapperEnumerable`1">
            <summary>
            Abstract implementation of an enumerable that wraps another enumerable
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AbstractWrapperEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new enumerable
            </summary>
            <param name="enumerable">Enumerable to wrap</param>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AbstractWrapperEnumerable`1.GetEnumerator">
            <summary>
            Gets an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AbstractWrapperEnumerable`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.AbstractWrapperEnumerable`1.InnerEnumerable">
            <summary>
            Gets the wrapped enumerable
            </summary>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AbstractEqualityEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new enumerable
            </summary>
            <param name="enumerable">Enumerable to wrap</param>
            <param name="equalityComparer">Equality comparer to use</param>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.AbstractEqualityEnumerable`1.EqualityComparer">
            <summary>
            Gets the equality comparer to use
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.Enumerations.AbstractEqualityEnumerator`1">
            <summary>
            Abstract implementation of a wrapper enumerator that needs item equality
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="T:VDS.Common.Collections.Enumerations.AbstractWrapperEnumerator`1">
            <summary>
            Abstract implementation of an enumerator that wraps another enumerator
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AbstractWrapperEnumerator`1.#ctor(System.Collections.Generic.IEnumerator{`0})">
            <summary>
            Creates a new enumerator
            </summary>
            <param name="enumerator">Enumerator to wrap</param>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AbstractWrapperEnumerator`1.Dispose">
            <summary>
            Disposes of this enumerator
            </summary>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AbstractWrapperEnumerator`1.MoveNext">
            <summary>
            Gets whether the enumerator can move to the next item
            </summary>
            <returns>True if another item is available, false otherwise</returns>
            <remarks>
            This differs to the abstract method <see cref="M:VDS.Common.Collections.Enumerations.AbstractWrapperEnumerator`1.TryMoveNext(`0@)"/> which derived classes must implement to determine if it can move next and what the next item is
            </remarks>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AbstractWrapperEnumerator`1.TryMoveNext(`0@)">
            <summary>
            Tries to move next
            </summary>
            <param name="item">Next item (if available)</param>
            <returns>True if another item is available, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AbstractWrapperEnumerator`1.Reset">
            <summary>
            Resets the enumerator
            </summary>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AbstractWrapperEnumerator`1.ResetInternal">
            <summary>
            Takes any implementation specific reset actions, should be overridden by derived classes that need to reset internal state
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.AbstractWrapperEnumerator`1.InnerEnumerator">
            <summary>
            Gets the wrapped enumerator
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.AbstractWrapperEnumerator`1.Started">
            <summary>
            Gets/Sets whether the enumeration has started
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.AbstractWrapperEnumerator`1.Finished">
            <summary>
            Gets/Sets whether the enumeration has finished
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.AbstractWrapperEnumerator`1.Current">
            <summary>
            Gets/Sets the current item
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.AbstractWrapperEnumerator`1.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current item
            </summary>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AbstractEqualityEnumerator`1.#ctor(System.Collections.Generic.IEnumerator{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new enumerator
            </summary>
            <param name="enumerator">Enumerator to wrap</param>
            <param name="equalityComparer">Equality comparer to use</param>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.AbstractEqualityEnumerator`1.EqualityComparer">
            <summary>
            Gets the equality comparer to use
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.Enumerations.AbstractOrderedEnumerable`1">
            <summary>
            Abstract implementation of a wrapper enumerable that uses item ordering
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AbstractOrderedEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new enumerable
            </summary>
            <param name="enumerable">Enumerable to wrap</param>
            <param name="comparer">Comparer to use</param>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.AbstractOrderedEnumerable`1.Comparer">
            <summary>
            Gets the comparer to use for ordering
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.Enumerations.AbstractOrderedEnumerator`1">
            <summary>
            Abstract implementation of a wrapper enumerator that uses item ordering
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AbstractOrderedEnumerator`1.#ctor(System.Collections.Generic.IEnumerator{`0},System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new enumerator
            </summary>
            <param name="enumerator">Enumerator to wrap</param>
            <param name="comparer">Comparer to use</param>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.AbstractOrderedEnumerator`1.Comparer">
            <summary>
            Gets the comparer to use for ordering
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.Enumerations.AbstractTopNEnumerable`1">
            <summary>
            Abstract implementation of a Top N enumerable
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AbstractTopNEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0},System.Int64)">
            <summary>
            Creates a new enumerable
            </summary>
            <param name="enumerable">Enumerable to operate over</param>
            <param name="comparer">Comparer to use for ordering</param>
            <param name="n">Number of items to return</param>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AbstractTopNEnumerable`1.GetEnumerator">
            <summary>
            Gets an enumerator
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.AbstractTopNEnumerable`1.N">
            <summary>
            Gets the maximum number of items to be yielded
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.Enumerations.AbstractTopNEnumerator`1">
            <summary>
            Abstract implementation of a Top N enumerator
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AbstractTopNEnumerator`1.#ctor(System.Collections.Generic.IEnumerator{`0},System.Collections.Generic.IComparer{`0},System.Int64)">
            <summary>
            Creates a new enumerator
            </summary>
            <param name="enumerator">Enumerator to operate over</param>
            <param name="comparer">Comparer to use for ordering</param>
            <param name="n">Number of items to return</param>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AbstractTopNEnumerator`1.TryMoveNext(`0@)">
            <summary>
            Tries to move next
            </summary>
            <param name="item">Item</param>
            <returns>True if more items, false otherwise</returns>
            <remarks>
            If this is the first time the enumerator is trying to move next it will build the top items list by consuming the inner enumerator and storing the top N items in a temporary data structure.  Once it has done that it will then return items from that data structure until they are exhausted
            </remarks>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AbstractTopNEnumerator`1.ResetInternal">
            <summary>
            Resets the enumerator
            </summary>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AbstractTopNEnumerator`1.BuildTopItems">
            <summary>
            Requests that the top items enumerator be built
            </summary>
            <returns>Top Items enumerator</returns>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.AbstractTopNEnumerator`1.N">
            <summary>
            Gets the number of items to be returned
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.AbstractTopNEnumerator`1.TopItemsEnumerator">
            <summary>
            Gets/Sets the Top Items enumerator
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.Enumerations.AddIfMissingEnumerable`1">
            <summary>
            An enumerable that adds the given item if it is not seen in the inner enumerable
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AddIfMissingEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0},`0)">
            <summary>
            Creates a new enumerable
            </summary>
            <param name="enumerable">Enumerable to operate over</param>
            <param name="equalityComparer">Equality comparer to use</param>
            <param name="item">Item to add if not present in inner enumerable</param>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AddIfMissingEnumerable`1.GetEnumerator">
            <summary>
            Gets an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.AddIfMissingEnumerable`1.AdditionalItem">
            <summary>
            Gets the additional item
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.Enumerations.AddIfEmptyEnumerable`1">
            <summary>
            An enumerable that adds an additional item if the enumerable it operates over is empty
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AddIfEmptyEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0},`0)">
            <summary>
            Creates a new enumerable
            </summary>
            <param name="enumerable">Enumerable to operate over</param>
            <param name="item">Item to add if enumerable is empty</param>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AddIfEmptyEnumerable`1.GetEnumerator">
            <summary>
            Gets an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.AddIfEmptyEnumerable`1.AdditionalItem">
            <summary>
            Gets the item to be added if the enumerable is empty
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.Enumerations.AddIfEmptyEnumerator`1">
            <summary>
            An enumerator that adds an item if the inner enumerator is empty
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AddIfEmptyEnumerator`1.#ctor(System.Collections.Generic.IEnumerator{`0},`0)">
            <summary>
            Creates a new enumerator
            </summary>
            <param name="enumerator">Enumerator</param>
            <param name="item">Item to add</param>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AddIfEmptyEnumerator`1.TryMoveNext(`0@)">
            <summary>
            Tries to move next
            </summary>
            <param name="item">Item</param>
            <returns>True if an item is available, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AddIfEmptyEnumerator`1.ResetInternal">
            <summary>
            Resets the enumerator
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.AddIfEmptyEnumerator`1.AdditionalItem">
            <summary>
            Gets the item to be added
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.AddIfEmptyEnumerator`1.AnyItemsSeen">
            <summary>
            Gets/Sets whether any items were seen
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.AddIfEmptyEnumerator`1.IsCurrentAdditionalItem">
            <summary>
            Gets whether we are currently returning the additional item
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.Enumerations.AddIfMissingEnumerator`1">
            <summary>
            An enumerator that adds an item if it is not present in the inner enumerator
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AddIfMissingEnumerator`1.#ctor(System.Collections.Generic.IEnumerator{`0},System.Collections.Generic.IEqualityComparer{`0},`0)">
            <summary>
            Create a new enumerator
            </summary>
            <param name="enumerator">Enumerator to operate over</param>
            <param name="equalityComparer">Equality Comparer to use</param>
            <param name="item">Item to add if missing from inner enumerator</param>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AddIfMissingEnumerator`1.TryMoveNext(`0@)">
            <summary>
            Tries to move next
            </summary>
            <param name="item">Item</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.AddIfMissingEnumerator`1.ResetInternal">
            <summary>
            Resets the enumerator
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.AddIfMissingEnumerator`1.AdditionalItemSeen">
            <summary>
            Gets/Sets whether the item to be added was seen in the inner enumerator
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.AddIfMissingEnumerator`1.IsCurrentAdditionalItem">
            <summary>
            Gets/Sets whether we are currently returning the 
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.AddIfMissingEnumerator`1.AdditionalItem">
            <summary>
            Gets/Sets the additional item
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.Enumerations.EnumerableExtensions">
            <summary>
            Provides various extension methods which provide useful capabilities on enumerables
            </summary>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.EnumerableExtensions.LongSkip``1(System.Collections.Generic.IEnumerable{``0},System.Int64)">
            <summary>
            Skips a given number of items
            </summary>
            <typeparam name="T">Item type</typeparam>
            <param name="enumerable">Enumerable to operate over</param>
            <param name="toSkip">Number of items to skip</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.EnumerableExtensions.LongTake``1(System.Collections.Generic.IEnumerable{``0},System.Int64)">
            <summary>
            Takes a given number of items
            </summary>
            <typeparam name="T">Item type</typeparam>
            <param name="enumerable">Enumerable to operate over</param>
            <param name="toTake">Number of items to take</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.EnumerableExtensions.AddIfMissing``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Adds an item to the enumerable provided it is not already present
            </summary>
            <typeparam name="T">Item type</typeparam>
            <param name="enumerable">Enumerable to operate over</param>
            <param name="item">Item to add if it is not already present</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.EnumerableExtensions.AddIfMissing``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0},``0)">
            <summary>
            Adds an item to the enumerable provided it is not already present
            </summary>
            <typeparam name="T">Item type</typeparam>
            <param name="enumerable">Enumerable to operate over</param>
            <param name="equalityComparer">Equality comparer to use</param>
            <param name="item">Item to add if it is not already present</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.EnumerableExtensions.AddIfEmpty``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Adds an item if the enumerable is empty
            </summary>
            <typeparam name="T">Item type</typeparam>
            <param name="enumerable">Enumerable to operate over</param>
            <param name="item">Item to add if the enumerable is empty</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.EnumerableExtensions.Reduced``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns an enumerable which eliminates adjacent duplicates from the given enumerable
            </summary>
            <typeparam name="T">Type</typeparam>
            <param name="enumerable">Enumerable</param>
            <returns>Enumerable which removes adjacent duplicates</returns>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.EnumerableExtensions.Reduced``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns an enumerable which eliminates adjacent duplicates from the given enumerable
            </summary>
            <typeparam name="T">Type</typeparam>
            <param name="enumerable">Enumerable</param>
            <param name="equalityComparer">Equality comparer to use</param>
            <returns>Enumerable which removes adjacent duplicates</returns>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.EnumerableExtensions.TopDistinct``1(System.Collections.Generic.IEnumerable{``0},System.Int64,System.Collections.Generic.IComparer{``0})">
            <summary>
            Gets the top N distinct items according to a given ordering
            </summary>
            <typeparam name="T">Item type</typeparam>
            <param name="enumerable">Enumerable to operate over</param>
            <param name="n">Number of items desired</param>
            <param name="comparer">Comparer used to order items</param>
            <returns></returns>
            <remarks>
            This differs from just doing a standard <code>.OrderBy().Take()</code> in that it does not need to hold the entire enumeration in memory at any time, it only ever holds at most <paramref name="n"/> items.
            </remarks>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.EnumerableExtensions.TopDistinct``1(System.Collections.Generic.IEnumerable{``0},System.Int64)">
            <summary>
            Gets the top N distinct items according to the default ordering
            </summary>
            <typeparam name="T">Item type</typeparam>
            <param name="enumerable">Enumerable to operate over</param>
            <param name="n">Number of items desired</param>
            <returns></returns>
            <remarks>
            This differs from just doing a standard <code>.OrderBy().Take()</code> in that it does not need to hold the entire enumeration in memory at any time, it only ever holds at most <paramref name="n"/> items.
            </remarks>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.EnumerableExtensions.Top``1(System.Collections.Generic.IEnumerable{``0},System.Int64,System.Collections.Generic.IComparer{``0})">
            <summary>
            Gets the top N items according to a given ordering
            </summary>
            <typeparam name="T">Item type</typeparam>
            <param name="enumerable">Enumerable to operate over</param>
            <param name="n">Number of items desired</param>
            <param name="comparer">Comparer used to order items</param>
            <returns></returns>
            <remarks>
            This differs from just doing a standard <code>.OrderBy().Take()</code> in that it does not need to hold the entire enumeration in memory at any time, it only ever holds at most <paramref name="n"/> items.
            </remarks>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.EnumerableExtensions.Top``1(System.Collections.Generic.IEnumerable{``0},System.Int64)">
            <summary>
            Gets the top N items according to the default ordering
            </summary>
            <typeparam name="T">Item type</typeparam>
            <param name="enumerable">Enumerable to operate over</param>
            <param name="n">Number of items desired</param>
            <returns></returns>
            <remarks>
            This differs from just doing a standard <code>.OrderBy().Take()</code> in that it does not need to hold the entire enumeration in memory at any time, it only ever holds at most <paramref name="n"/> items.
            </remarks>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.EnumerableExtensions.BottomDistinct``1(System.Collections.Generic.IEnumerable{``0},System.Int64,System.Collections.Generic.IComparer{``0})">
            <summary>
            Gets the bottom N items distinct according to a given ordering
            </summary>
            <typeparam name="T">Item type</typeparam>
            <param name="enumerable">Enumerable to operate over</param>
            <param name="n">Number of items desired</param>
            <param name="comparer">Comparer used to order items</param>
            <returns></returns>
            <remarks>
            This differs from just doing a standard <code>.OrderByDescending().Take()</code> in that it does not need to hold the entire enumeration in memory at any time, it only ever holds at most <paramref name="n"/> items.
            </remarks>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.EnumerableExtensions.BottomDistinct``1(System.Collections.Generic.IEnumerable{``0},System.Int64)">
            <summary>
            Gets the bottom N items distinct according to the default ordering
            </summary>
            <typeparam name="T">Item type</typeparam>
            <param name="enumerable">Enumerable to operate over</param>
            <param name="n">Number of items desired</param>
            <returns></returns>
            <remarks>
            This differs from just doing a standard <code>.OrderByDescending().Take()</code> in that it does not need to hold the entire enumeration in memory at any time, it only ever holds at most <paramref name="n"/> items.
            </remarks>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.EnumerableExtensions.Bottom``1(System.Collections.Generic.IEnumerable{``0},System.Int64,System.Collections.Generic.IComparer{``0})">
            <summary>
            Gets the bottom N items according to a given ordering
            </summary>
            <typeparam name="T">Item type</typeparam>
            <param name="enumerable">Enumerable to operate over</param>
            <param name="n">Number of items desired</param>
            <param name="comparer">Comparer used to order items</param>
            <returns></returns>
            <remarks>
            This differs from just doing a standard <code>.OrderByDescending().Take()</code> in that it does not need to hold the entire enumeration in memory at any time, it only ever holds at most <paramref name="n"/> items.
            </remarks>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.EnumerableExtensions.Bottom``1(System.Collections.Generic.IEnumerable{``0},System.Int64)">
            <summary>
            Gets the bottom N items according to a given ordering
            </summary>
            <typeparam name="T">Item type</typeparam>
            <param name="enumerable">Enumerable to operate over</param>
            <param name="n">Number of items desired</param>
            <returns></returns>
            <remarks>
            This differs from just doing a standard <code>.OrderByDescending().Take()</code> in that it does not need to hold the entire enumeration in memory at any time, it only ever holds at most <paramref name="n"/> items.
            </remarks>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.EnumerableExtensions.ProbabilisticDistinct``1(System.Collections.Generic.IEnumerable{``0},System.Int64,System.Int64,System.Func{``0,System.Int32},System.Func{``0,System.Int32})">
            <summary>
            Gets an enumerable whose items are probablisticly distinct, this may exclude some distinct items that a normal <see cref="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0})"/> would include
            </summary>
            <typeparam name="T">Item type</typeparam>
            <param name="enumerable">Enumerable to operate over</param>
            <param name="expectedItems">How many distinct items you expect to process</param>
            <param name="errorRate">Desired error (false positive) rate, treated as 1 in N</param>
            <param name="h1">Hash function</param>
            <param name="h2">Another hash function</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.EnumerableExtensions.ProbabilisticDistinct``1(System.Collections.Generic.IEnumerable{``0},System.Int64,System.Double,System.Func{``0,System.Int32},System.Func{``0,System.Int32})">
            <summary>
            Gets an enumerable whose items are probablisticly distinct, this may exclude some distinct items that a normal <see cref="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0})"/> would include
            </summary>
            <typeparam name="T">Item type</typeparam>
            <param name="enumerable">Enumerable to operate over</param>
            <param name="expectedItems">How many distinct items you expect to process</param>
            <param name="errorRate">Desired error (false positive) rate expressed as value between 0.0 and 1.0</param>
            <param name="h1">Hash function</param>
            <param name="h2">Another hash function</param>
            <returns></returns>
        </member>
        <member name="T:VDS.Common.Collections.Enumerations.LongSkipEnumerable`1">
            <summary>
            An enumerable that skips items
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.LongSkipEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int64)">
            <summary>
            Creates a new enumerable
            </summary>
            <param name="enumerable">Enumerable to operate over</param>
            <param name="toSkip">Number of items to skip</param>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.LongSkipEnumerable`1.GetEnumerator">
            <summary>
            Gets the enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.LongSkipEnumerable`1.ToSkip">
            <summary>
            Gets/Sets the number of items to skip
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.Enumerations.LongSkipEnumerator`1">
            <summary>
            An enumerator that skips items
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.LongSkipEnumerator`1.#ctor(System.Collections.Generic.IEnumerator{`0},System.Int64)">
            <summary>
            Creates a new enumerator
            </summary>
            <param name="enumerator">Enumerator to operate over</param>
            <param name="toSkip">Number of items to skip</param>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.LongSkipEnumerator`1.TrySkip">
            <summary>
            Tries to skip the desired number of items
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.LongSkipEnumerator`1.TryMoveNext(`0@)">
            <summary>
            Tries to move next
            </summary>
            <param name="item">Item</param>
            <returns></returns>
            <remarks>
            The first time this is called it will try to skip the requisite number of items from the inner enumerator, if that succeeds it will then start returning items from the inner enumerator.
            </remarks>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.LongSkipEnumerator`1.ResetInternal">
            <summary>
            Resets the enumerator
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.LongSkipEnumerator`1.ToSkip">
            <summary>
            Gets/Sets the number of items to skip
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.LongSkipEnumerator`1.Skipped">
            <summary>
            Gets/Sets the number of items skipped
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.Enumerations.LongTakeEnumerable`1">
            <summary>
            An enumerable that takes some number of items
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.LongTakeEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int64)">
            <summary>
            Creates a new enumerable
            </summary>
            <param name="enumerable">Enumerable to operate over</param>
            <param name="toTake">Number of items to take</param>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.LongTakeEnumerable`1.GetEnumerator">
            <summary>
            Gets an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.LongTakeEnumerable`1.ToTake">
            <summary>
            Gets/Sets the number of items to take
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.Enumerations.LongTakeEnumerator`1">
            <summary>
            An enumerator that takes some number of items
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.LongTakeEnumerator`1.#ctor(System.Collections.Generic.IEnumerator{`0},System.Int64)">
            <summary>
            Creates a new enumerator
            </summary>
            <param name="enumerator">Enumerator to operate over</param>
            <param name="toTake">Number of items to take</param>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.LongTakeEnumerator`1.TryMoveNext(`0@)">
            <summary>
            Tries to move next
            </summary>
            <param name="item">Item</param>
            <returns></returns>
            <remarks>
            While the number of items seen is less than the desired number of items the inner enumerator is accessed normally, once that is reached no further items are returned
            </remarks>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.LongTakeEnumerator`1.ResetInternal">
            <summary>
            Resets the enumerator
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.LongTakeEnumerator`1.ToTake">
            <summary>
            Gets/Sets the number of items to take
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.LongTakeEnumerator`1.Taken">
            <summary>
            Gets/Sets the number of items taken
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.Enumerations.ProbabilisticDistinctEnumerable`1">
            <summary>
            An enumerable that reduces another enumerable by using a bloom filter to give probably distinct results
            </summary>
            <typeparam name="T">Item type</typeparam>
            <remarks>
            All items returned are guaranteed to be distinct (based upon the hash functions used for the filter) but some items may be erroneously omitted as bloom filters can produce false positives
            </remarks>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.ProbabilisticDistinctEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{VDS.Common.Filters.IBloomFilter{`0}})">
            <summary>
            Creates a new enumerable
            </summary>
            <param name="enumerable">Enumerable</param>
            <param name="filterFactory">Filter factory function</param>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.ProbabilisticDistinctEnumerable`1.GetEnumerator">
            <summary>
            Gets an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.ProbabilisticDistinctEnumerable`1.FilterFactory">
            <summary>
            Gets/Sets a factory method that produces a bloom filter to use
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.Enumerations.ProbabilisticDistinctEnumerator`1">
            <summary>
            An enumerator that reduces another enumerator by using a bloom filter to give probably distinct results
            </summary>
            <typeparam name="T"></typeparam>
            <remarks>
            All items returned are guaranteed to be distinct (based upon the hash functions used for the filter) but some items may be erroneously omitted as bloom filters can produce false positives
            </remarks>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.ProbabilisticDistinctEnumerator`1.#ctor(System.Collections.Generic.IEnumerator{`0},VDS.Common.Filters.IBloomFilter{`0})">
            <summary>
            Creates a new enumerator
            </summary>
            <param name="enumerator">Enumerator to operate over</param>
            <param name="filter">Bloom filter to use for distinctness</param>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.ProbabilisticDistinctEnumerator`1.TryMoveNext(`0@)">
            <summary>
            Tries to move next
            </summary>
            <param name="item">Item</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.ProbabilisticDistinctEnumerator`1.ResetInternal">
            <summary>
            Resets the bloom filter used
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.ProbabilisticDistinctEnumerator`1.Filter">
            <summary>
            Gets/Sets the bloom filter to use
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.Enumerations.ReducedEnumerable`1">
            <summary>
            An enumerable that reduces the items returns by omitting adjacent duplicates
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.ReducedEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new enumerable
            </summary>
            <param name="enumerable">Enumerable to operate over</param>
            <param name="equalityComparer">Equality comparer to use</param>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.ReducedEnumerable`1.GetEnumerator">
            <summary>
            Gets an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.Common.Collections.Enumerations.ReducedEnumerator`1">
            <summary>
            Gets an enumerator that reduces another enumerator by eliminating adjacent duplicates
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.ReducedEnumerator`1.#ctor(System.Collections.Generic.IEnumerator{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new enumerator
            </summary>
            <param name="enumerator">Enumerator to operate over</param>
            <param name="equalityComparer">Equality comparer to use</param>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.ReducedEnumerator`1.TryMoveNext(`0@)">
            <summary>
            Tries to move next
            </summary>
            <param name="item">Item</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.ReducedEnumerator`1.ResetInternal">
            <summary>
            Resets the 
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.ReducedEnumerator`1.First">
            <summary>
            Gets/Sets whether we are at the first item
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.ReducedEnumerator`1.LastItem">
            <summary>
            Gets the last item seen
            </summary>
        </member>
        <member name="T:VDS.Common.Comparers.ReferenceEqualityComparer`1">
            <summary>
            An equality comparer based purely on Object reference
            </summary>
            <typeparam name="T">Type</typeparam>
        </member>
        <member name="M:VDS.Common.Comparers.ReferenceEqualityComparer`1.Equals(`0,`0)">
            <summary>
            Gets whether two items are reference equals
            </summary>
            <param name="x">Item</param>
            <param name="y">Other item</param>
            <returns>True if items are reference equals, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Comparers.ReferenceEqualityComparer`1.GetHashCode(`0)">
            <summary>
            Gets a hash code for an item
            </summary>
            <param name="obj">Item</param>
            <returns>Hash code</returns>
            <remarks>
            Defers to <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)"/>
            </remarks>
        </member>
        <member name="T:VDS.Common.Comparers.ReversedComparer`1">
            <summary>
            A comparer that reverses the ordering provided by another comparer
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="M:VDS.Common.Comparers.ReversedComparer`1.#ctor">
            <summary>
            Creates a new comparer that reverses the default ordering
            </summary>
        </member>
        <member name="M:VDS.Common.Comparers.ReversedComparer`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new comparer that reverses the given ordering
            </summary>
            <param name="comparer">Comparer</param>
        </member>
        <member name="M:VDS.Common.Comparers.ReversedComparer`1.Compare(`0,`0)">
            <summary>
            Compares two items
            </summary>
            <param name="x">Item</param>
            <param name="y">Other item</param>
            <returns></returns>
        </member>
        <member name="P:VDS.Common.Comparers.ReversedComparer`1.InnerComparer">
            <summary>
            Gets the inner comparer
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.Enumerations.TopNDistinctEnumerator`1">
            <summary>
            An enumerator that returns the top N distinct items accoding to some ordering
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.TopNDistinctEnumerator`1.#ctor(System.Collections.Generic.IEnumerator{`0},System.Collections.Generic.IComparer{`0},System.Int64)">
            <summary>
            Creates a new enumerator
            </summary>
            <param name="enumerator">Enumerator to operate over</param>
            <param name="comparer">Comparer to use</param>
            <param name="n">Number of items to return</param>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.TopNDistinctEnumerator`1.BuildTopItems">
            <summary>
            Builds the top items
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.TopNDistinctEnumerator`1.TopItems">
            <summary>
            Gets/Sets the tree of stored items
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.Enumerations.TopNEnumerable`1">
            <summary>
            An enumerable that returns the top N items according to some ordering
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.TopNEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0},System.Int64)">
            <summary>
            Creates a new enumerable
            </summary>
            <param name="enumerable">Enumerable to operate over</param>
            <param name="comparer">Comparer to use</param>
            <param name="n">Number of items to return</param>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.TopNEnumerable`1.GetEnumerator">
            <summary>
            Gets an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.Common.Collections.Enumerations.TopNDistinctEnumerable`1">
            <summary>
            An enumerable that returns only the top N distinct items according to an ordering
            </summary>
            <typeparam name="T">Item type</typeparam>
            <remarks>
            This is a memory efficient implementation that only needs to store at most N items at any one time
            </remarks>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.TopNDistinctEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0},System.Int64)">
            <summary>
            Creates a new enumerable
            </summary>
            <param name="enumerable">Enumerable</param>
            <param name="comparer">Comparer to use</param>
            <param name="n">Number of items to return</param>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.TopNDistinctEnumerable`1.GetEnumerator">
            <summary>
            Gets an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.Common.Collections.Enumerations.TopNEnumerator`1">
            <summary>
            An enumerator that returns the top N items based on a given ordering
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.TopNEnumerator`1.#ctor(System.Collections.Generic.IEnumerator{`0},System.Collections.Generic.IComparer{`0},System.Int64)">
            <summary>
            Creates a new enumerator
            </summary>
            <param name="enumerator">Enumerator to operate over</param>
            <param name="comparer">Comparer to use</param>
            <param name="n">Number of items to return</param>
        </member>
        <member name="M:VDS.Common.Collections.Enumerations.TopNEnumerator`1.BuildTopItems">
            <summary>
            Builds the top items
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.Common.Collections.Enumerations.TopNEnumerator`1.TopItems">
            <summary>
            Stores the top N items
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.ImmutableView`1">
            <summary>
            An implementation of <see cref="T:System.Collections.Generic.ICollection`1"/> which is an immutable view over some enumerable
            </summary>
            <typeparam name="T">Type</typeparam>
        </member>
        <member name="F:VDS.Common.Collections.ImmutableView`1._items">
            <summary>
            The enumerable being wrapped
            </summary>
        </member>
        <member name="M:VDS.Common.Collections.ImmutableView`1.#ctor">
            <summary>
            Creates a new immutable view over an empty collection
            </summary>
        </member>
        <member name="M:VDS.Common.Collections.ImmutableView`1.#ctor(System.String)">
            <summary>
            Creates a new immutable view over an empty collection
            </summary>
            <param name="message">Error message to throw when mutation actions are attempted</param>
        </member>
        <member name="M:VDS.Common.Collections.ImmutableView`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.String)">
            <summary>
            Creates a new immutable view
            </summary>
            <param name="items">Enumerable to provide view over</param>
            <param name="message">Error message to throw when mutation actions are attempted</param>
        </member>
        <member name="M:VDS.Common.Collections.ImmutableView`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new immutable view
            </summary>
            <param name="items">Enumerable to provide view over</param>
        </member>
        <member name="M:VDS.Common.Collections.ImmutableView`1.Add(`0)">
            <summary>
            Throws an error as this collection is immutable
            </summary>
            <param name="item">Item</param>
            <exception cref="T:System.NotSupportedException">Thrown because the collection is immutable</exception>
        </member>
        <member name="M:VDS.Common.Collections.ImmutableView`1.Clear">
            <summary>
            Throws an error as this collection is immutable
            </summary>
            <exception cref="T:System.NotSupportedException">Thrown because the collection is immutable</exception>
        </member>
        <member name="M:VDS.Common.Collections.ImmutableView`1.Contains(`0)">
            <summary>
            Checks whether the collection contains a given item
            </summary>
            <param name="item">Item</param>
            <returns>True if the item is contained in the collection, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Collections.ImmutableView`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the collection into an array
            </summary>
            <param name="array">Array</param>
            <param name="arrayIndex">Index to start the copying at</param>
        </member>
        <member name="M:VDS.Common.Collections.ImmutableView`1.Remove(`0)">
            <summary>
            Throws an error as this collection is immutable
            </summary>
            <param name="item">Item</param>
            <exception cref="T:System.NotSupportedException">Thrown because the collection is immutable</exception>
        </member>
        <member name="M:VDS.Common.Collections.ImmutableView`1.GetEnumerator">
            <summary>
            Gets an enumerator for the collection
            </summary>
            <returns>Enumerator over the collection</returns>
        </member>
        <member name="M:VDS.Common.Collections.ImmutableView`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator for the collection
            </summary>
            <returns>Enumerator over the collection</returns>
        </member>
        <member name="P:VDS.Common.Collections.ImmutableView`1.Count">
            <summary>
            Gets the count of items in the collection
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.ImmutableView`1.IsReadOnly">
            <summary>
            Returns that the collection is read-only
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.MaterializedImmutableView`1">
            <summary>
            A version of <see cref="T:VDS.Common.Collections.ImmutableView`1"/> where the enumerable is materialized as a list internally
            </summary>
            <typeparam name="T">Type</typeparam>
        </member>
        <member name="M:VDS.Common.Collections.MaterializedImmutableView`1.#ctor">
            <summary>
            Creates a new immutable view over an empty collection
            </summary>
        </member>
        <member name="M:VDS.Common.Collections.MaterializedImmutableView`1.#ctor(System.String)">
            <summary>
            Creates a new immutable view over an empty collection
            </summary>
            <param name="message">Error message to throw when mutation actions are attempted</param>
        </member>
        <member name="M:VDS.Common.Collections.MaterializedImmutableView`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.String)">
            <summary>
            Creates a new immutable view
            </summary>
            <param name="items">Enumerable to provide view over</param>
            <param name="message">Error message to throw when mutation actions are attempted</param>
        </member>
        <member name="M:VDS.Common.Collections.MaterializedImmutableView`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new immutable view
            </summary>
            <param name="items">Enumerable to provide view over</param>
        </member>
        <member name="M:VDS.Common.Collections.MaterializedImmutableView`1.Contains(`0)">
            <summary>
            Checks whether the collection contains a given item
            </summary>
            <param name="item">Item</param>
            <returns>True if the item is contained in the collection, false otherwise</returns>
        </member>
        <member name="P:VDS.Common.Collections.MaterializedImmutableView`1.Count">
            <summary>
            Gets the count of items in the collection
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.LinkedSparseArray`1">
            <summary>
            A memory efficient sparse array backed by a <see cref="T:System.Collections.Generic.LinkedList`1"/> thus it trades lookup performance off against memory.  
            </summary>
            <remarks>
            <para>
            This implementation is extremely memory efficient for sparse arrays since it only stores entries where the value has been set.  However the use of a linked list means lookup of a specific index is a worse case O(n) operation where n is the length of the list.
            </para>
            <para>
            If fast access is preferred over memory efficiency then the <see cref="T:VDS.Common.Collections.BlockSparseArray`1"/> may be a better option
            </para>
            </remarks>
            <typeparam name="T">Value type</typeparam>
        </member>
        <member name="M:VDS.Common.Collections.LinkedSparseArray`1.#ctor(System.Int32)">
            <summary>
            Creates a new sparse array with the given length
            </summary>
            <param name="length">Length</param>
        </member>
        <member name="M:VDS.Common.Collections.LinkedSparseArray`1.GetEnumerator">
            <summary>
            Gets an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Collections.LinkedSparseArray`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Collections.LinkedSparseArray`1.Clear">
            <summary>
            Clears the array
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.LinkedSparseArray`1.Item(System.Int32)">
            <summary>
            Gets/Sets the value at the given index
            </summary>
            <param name="index">Index</param>
            <returns>Value</returns>
        </member>
        <member name="P:VDS.Common.Collections.LinkedSparseArray`1.Length">
            <summary>
            Gets the length of the array
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.MultiDictionaryMode">
            <summary>
            Possible modes to use for the binary search tree based buckets of the <see cref="T:VDS.Common.Collections.MultiDictionary`2"/>
            </summary>
        </member>
        <member name="F:VDS.Common.Collections.MultiDictionaryMode.Unbalanced">
            <summary>
            Use unbalanced trees, best when you expect minimal key collisions and are willing to trade faster insert performance for slower lookup performance
            </summary>
        </member>
        <member name="F:VDS.Common.Collections.MultiDictionaryMode.Scapegoat">
            <summary>
            Use Scapegoat trees, good when there are a few key collisions and key comparisons are inexpensive.  Provides amortized O(log n) performance but ocassional operations may be O(n)
            </summary>
        </member>
        <member name="F:VDS.Common.Collections.MultiDictionaryMode.AVL">
            <summary>
            Use AVL trees, likely gives the best overall performance
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.MultiDictionary`2">
            <summary>
            An advanced dictionary implementation
            </summary>
            <typeparam name="TKey">Key Type</typeparam>
            <typeparam name="TValue">Value Type</typeparam>
            <remarks>
            <para>
            A multi-dictionary is essentially just a dictionary which deals more efficiently with key collisions, with a normal .Net dictionary colliding hash codes cause performance degradation which makes them less than ideal for certain use cases such as indexes.  A multi-dictionary can also handle null keys provided that the hash function in use can cope with these.
            </para>
            <para>
            With this implementation the keys are used to split the values into buckets and then each bucket uses a binary search tree to maintain full information about the keys and values.  This means that all keys and values are properly preserved and keys cannot interfer with each other in most cases.  In the case where keys have the same hash code and compare to be equal then they will interfere with each other but that is the correct behaviour.  The implementation is designed to be flexible in that it allows you to specify the hash function, the comparer used and the form of tree used for the buckets.
            </para>
            <para>
            This means the multi-dictionary gives slightly worse performance than a dictionary for well distributed data with minimal key collisions but provides order of magnitude better performance for data with lots of hash collisions.  This makes it ideal as a use for an indexing structure since you can index using partial properties of the keys (thus giving hash code collisions) while still preserving all the keys.
            </para>
            <h3>Null Key Handling</h3>
            <para>
            A MultiDictionary is capable of handling null keys when the key type is a nullable type provided that the hash function used supports them.  To determine this it will attempt to apply the hash function to <em>default(TKey)</em> in the constructor, if the hash function supports null keys or the key type is non-nullable this will succeed and it will allow null keys.  If a <see cref="T:System.NullReferenceException"/> is thrown it will ignore the error and use the default behaviour of forbidding null keys, any attempt to use a null key in this case will result in an <see cref="T:System.ArgumentNullException"/>
            </para>
            </remarks>
        </member>
        <member name="F:VDS.Common.Collections.MultiDictionary`2.DefaultMode">
            <summary>
            Default Mode for Multi-Dictionaries
            </summary>
        </member>
        <member name="M:VDS.Common.Collections.MultiDictionary`2.#ctor">
            <summary>
            Creates a new multi-dictionary
            </summary>
        </member>
        <member name="M:VDS.Common.Collections.MultiDictionary`2.#ctor(VDS.Common.Collections.MultiDictionaryMode)">
            <summary>
            Creates a new multi-dictionary
            </summary>
            <param name="mode">Mode to use for the buckets</param>
        </member>
        <member name="M:VDS.Common.Collections.MultiDictionary`2.#ctor(System.Func{`0,System.Int32})">
            <summary>
            Creates a new multi-dictionary
            </summary>
            <param name="hashFunction">Hash Function to split the keys into the buckets</param>
        </member>
        <member name="M:VDS.Common.Collections.MultiDictionary`2.#ctor(System.Func{`0,System.Int32},System.Boolean)">
            <summary>
            Creates a new multi-dictionary
            </summary>
            <param name="hashFunction">Hash Function to split the keys into the buckets</param>
            <param name="allowNullKeys">Whether to allow null keys</param>
        </member>
        <member name="M:VDS.Common.Collections.MultiDictionary`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new multi-dictionary
            </summary>
            <param name="comparer">Comparer used for keys within the binary search trees</param>
        </member>
        <member name="M:VDS.Common.Collections.MultiDictionary`2.#ctor(System.Func{`0,System.Int32},VDS.Common.Collections.MultiDictionaryMode)">
            <summary>
            Creates a new multi-dictionary
            </summary>
            <param name="hashFunction">Hash Function to split the keys into the buckets</param>
            <param name="mode">Mode to use for the buckets</param>
        </member>
        <member name="M:VDS.Common.Collections.MultiDictionary`2.#ctor(System.Func{`0,System.Int32},System.Boolean,VDS.Common.Collections.MultiDictionaryMode)">
            <summary>
            Creates a new multi-dictionary
            </summary>
            <param name="hashFunction">Hash Function to split the keys into the buckets</param>
            <param name="allowNullKeys">Whether to allow null keys</param>
            <param name="mode">Mode to use for the buckets</param>
        </member>
        <member name="M:VDS.Common.Collections.MultiDictionary`2.#ctor(System.Collections.Generic.IComparer{`0},VDS.Common.Collections.MultiDictionaryMode)">
            <summary>
            Creates a new multi-dictionary
            </summary>
            <param name="comparer">Comparer used for keys within the binary search trees</param>
            <param name="mode">Mode to use for the buckets</param>
        </member>
        <member name="M:VDS.Common.Collections.MultiDictionary`2.#ctor(System.Func{`0,System.Int32},System.Boolean,System.Collections.Generic.IComparer{`0},VDS.Common.Collections.MultiDictionaryMode)">
            <summary>
            Creates a new multi-dictionary
            </summary>
            <param name="hashFunction">Hash Function to splut the keys into the buckets</param>
            <param name="allowNullKeys">Whether null keys are allowed</param>
            <param name="comparer">Comparer used for keys within the binary search trees</param>
            <param name="mode">Mode to use for the buckets</param>
        </member>
        <member name="M:VDS.Common.Collections.MultiDictionary`2.CreateTree">
            <summary>
            Creates a new Tree to be used as a key/value bucket
            </summary>
            <returns>Tree to use as the bucket</returns>
        </member>
        <member name="M:VDS.Common.Collections.MultiDictionary`2.Add(`0,`1)">
            <summary>
            Adds a key value pair to the dictionary
            </summary>
            <param name="key">Key</param>
            <param name="value">Value</param>
        </member>
        <member name="M:VDS.Common.Collections.MultiDictionary`2.ContainsKey(`0)">
            <summary>
            Gets whether the dictionary contains the given key
            </summary>
            <param name="key">Key</param>
            <returns>True if the given key exists in the dictionary, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Collections.MultiDictionary`2.Remove(`0)">
            <summary>
            Removes a key value pair from the dictionary based on the key
            </summary>
            <param name="key">Key</param>
            <returns>True if a key value pair was removed, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Collections.MultiDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to get the value associated with a key
            </summary>
            <param name="key">Key</param>
            <param name="value">Value</param>
            <returns>True if the key exists in the dictionary and a value can be returned, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Collections.MultiDictionary`2.TryGetKey(`0,`0@)">
            <summary>
            Tries to get the actual key instance stored for a given key
            </summary>
            <param name="key">Key</param>
            <param name="actualKey">Actual Key</param>
            <returns>True if the key exists in the dictionary and the instance was returned, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Collections.MultiDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Adds a key value pair to the dictionary
            </summary>
            <param name="item">Key value pair</param>
        </member>
        <member name="M:VDS.Common.Collections.MultiDictionary`2.Clear">
            <summary>
            Clears the dictionary
            </summary>
        </member>
        <member name="M:VDS.Common.Collections.MultiDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Gets whether the dictionary contains a given key value pair
            </summary>
            <param name="item">Key value pair</param>
            <returns>True if the given key value pair exists in the dictionary</returns>
        </member>
        <member name="M:VDS.Common.Collections.MultiDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the dictionary into an array
            </summary>
            <param name="array">Array</param>
            <param name="arrayIndex">Index to start copying at</param>
        </member>
        <member name="M:VDS.Common.Collections.MultiDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Removes a key value pair from the dictionary
            </summary>
            <param name="item">Key value pair</param>
            <returns>True if the key value pair was removed from the dictionary</returns>
        </member>
        <member name="M:VDS.Common.Collections.MultiDictionary`2.GetEnumerator">
            <summary>
            Gets an enumerator for the key value pairs in the dictionary
            </summary>
            <returns>Enumerator over key value pairs</returns>
        </member>
        <member name="M:VDS.Common.Collections.MultiDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets the enumerator for the dictionary
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:VDS.Common.Collections.MultiDictionary`2.System#Collections#Generic#IEnumerable{TValue}#GetEnumerator">
            <summary>
            Gets the enumeration of values in the dictionary
            </summary>
            <returns>Enumerator over values</returns>
        </member>
        <member name="P:VDS.Common.Collections.MultiDictionary`2.Keys">
            <summary>
            Gets the keys of the dictionary
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.MultiDictionary`2.Values">
            <summary>
            Gets the values in the dictionary
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.MultiDictionary`2.Item(`0)">
            <summary>
            Gets/Sets a Value in the dictionary
            </summary>
            <param name="key">Key</param>
            <returns>The value associated with the given key</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the given key does not exist in the dictionary</exception>
        </member>
        <member name="P:VDS.Common.Collections.MultiDictionary`2.Count">
            <summary>
            Gets the number of values in the dictionary
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.MultiDictionary`2.IsReadOnly">
            <summary>
            Returns false because this dictionary is read/write
            </summary>
        </member>
        <member name="T:VDS.Common.Collections.TreeSortedDictionary`2">
            <summary>
            An implementation of a dictionary where the sort order of keys is preserved using a binary tree behind the scenes.  This makes all operations on the dictionary O(log n)
            </summary>
            <typeparam name="TKey">Key Type</typeparam>
            <typeparam name="TValue">Value Type</typeparam>
        </member>
        <member name="M:VDS.Common.Collections.TreeSortedDictionary`2.#ctor">
            <summary>
            Creates a new dictionary using the default comparer for the key type
            </summary>
        </member>
        <member name="M:VDS.Common.Collections.TreeSortedDictionary`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new dictionary using the given comparer for the keys
            </summary>
            <param name="comparer">Comparer</param>
        </member>
        <member name="M:VDS.Common.Collections.TreeSortedDictionary`2.Add(`0,`1)">
            <summary>
            Adds a key value pair to the dictionary
            </summary>
            <param name="key">Key</param>
            <param name="value">Value</param>
        </member>
        <member name="M:VDS.Common.Collections.TreeSortedDictionary`2.ContainsKey(`0)">
            <summary>
            Checks whether the dictionary contains the given key
            </summary>
            <param name="key">Key</param>
            <returns>True if the dictionary contains the key, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Collections.TreeSortedDictionary`2.Remove(`0)">
            <summary>
            Removes a key from the dictionary
            </summary>
            <param name="key">Key to remove</param>
            <returns>True if a key was removed, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Collections.TreeSortedDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to get the value associated with the given key
            </summary>
            <param name="key">Key</param>
            <param name="value">Value</param>
            <returns>True if a value has been returned</returns>
        </member>
        <member name="M:VDS.Common.Collections.TreeSortedDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Adds a key value pair to the dictionary
            </summary>
            <param name="item">Key Value pair</param>
        </member>
        <member name="M:VDS.Common.Collections.TreeSortedDictionary`2.Clear">
            <summary>
            Clears the dictionary
            </summary>
        </member>
        <member name="M:VDS.Common.Collections.TreeSortedDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Checks whether the dictionary contains the given key value pair
            </summary>
            <param name="item">Key Value pair</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Collections.TreeSortedDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the contents of the dictionary to an array
            </summary>
            <param name="array">Array</param>
            <param name="arrayIndex">Index to start copying elements at</param>
        </member>
        <member name="M:VDS.Common.Collections.TreeSortedDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Removes a key value pair from the dictionary
            </summary>
            <param name="item">Key Value pair</param>
            <returns>True if a key value pair was removed, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Collections.TreeSortedDictionary`2.GetEnumerator">
            <summary>
            Gets the enumerator of key value pairs
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Collections.TreeSortedDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets the enumerator of values
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Collections.TreeSortedDictionary`2.System#Collections#Generic#IEnumerable{TValue}#GetEnumerator">
            <summary>
            Gets the enumerator of values
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.Common.Collections.TreeSortedDictionary`2.Keys">
            <summary>
            Gets the collection of keys
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.TreeSortedDictionary`2.Values">
            <summary>
            Gets the collection of values in the dictionary
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.TreeSortedDictionary`2.Item(`0)">
            <summary>
            Gets/Sets the value associated with a key
            </summary>
            <param name="key">Key</param>
            <returns>Value</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the given key does not exist in the dictionary</exception>
        </member>
        <member name="P:VDS.Common.Collections.TreeSortedDictionary`2.Count">
            <summary>
            Gets the number of key value pairs in the dictionary
            </summary>
        </member>
        <member name="P:VDS.Common.Collections.TreeSortedDictionary`2.IsReadOnly">
            <summary>
            Gets whether the dictionary is read-only
            </summary>
        </member>
        <member name="T:VDS.Common.Extensions">
            <summary>
            Internal use extension methods
            </summary>
        </member>
        <member name="M:VDS.Common.Extensions.AsEnumerable``1(``0)">
            <summary>
            Turns a single item into an enumerable
            </summary>
            <typeparam name="T">Type</typeparam>
            <param name="item">Item</param>
            <returns>Enumerable containing the single item</returns>
        </member>
        <member name="M:VDS.Common.Extensions.ToSafeString(System.Object)">
            <summary>
            Gets the safe string representation of an object which is the ToString() result for non-null objects and String.Empty otherwise
            </summary>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="T:VDS.Common.Filters.BaseBloomFilter`1">
            <summary>
            Abstract implementation of a bloom filter
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="T:VDS.Common.Filters.BaseBloomFilterParameters">
            <summary>
            Abstract implementation of bloom filter parameters
            </summary>
        </member>
        <member name="T:VDS.Common.Filters.IBloomFilterParameters">
            <summary>
            Represents Bloom Filter parameters
            </summary>
        </member>
        <member name="P:VDS.Common.Filters.IBloomFilterParameters.NumberOfBits">
            <summary>
            Gets the number of bits used for the filter
            </summary>
        </member>
        <member name="P:VDS.Common.Filters.IBloomFilterParameters.NumberOfHashFunctions">
            <summary>
            Gets the number of hash functions used for the filter
            </summary>
        </member>
        <member name="P:VDS.Common.Filters.BaseBloomFilterParameters.NumberOfBits">
            <summary>
            Gets the number of bits
            </summary>
        </member>
        <member name="P:VDS.Common.Filters.BaseBloomFilterParameters.NumberOfHashFunctions">
            <summary>
            Gets the number of hash functions
            </summary>
        </member>
        <member name="T:VDS.Common.Filters.IBloomFilter`1">
            <summary>
            Interface for bloom filters which are a probabilistic data structure for detecting whether items have already been seen
            </summary>
            <typeparam name="T">Item type</typeparam>
            <remarks>
            A bloom filter is a data structure that can be used to determine whether an item may have previously been seen in a memory efficient way that does not require storing the actual items.  The trade off is that it may yield false positives however it is guaranteed to never yield false negatives.  This makes it an ideal data structure for implementings things like distinctness where it doesn't matter if a few non-distinct items are discarded.
            </remarks>
        </member>
        <member name="M:VDS.Common.Filters.IBloomFilter`1.Add(`0)">
            <summary>
            Adds an item to the filter
            </summary>
            <param name="item">Item</param>
            <returns>True if the item was added to the filter, false if item may already have been present and was not added</returns>
        </member>
        <member name="M:VDS.Common.Filters.IBloomFilter`1.MayContain(`0)">
            <summary>
            Gets whether the filter may have already seen the given item
            </summary>
            <param name="item">Item</param>
            <returns>True if the item may have been seen, false otherwise</returns>
            <remarks>
            Bloom filters may return false positives hence why this method is named <strong>MayContain</strong> but they are guaranteed to never return false negatives
            </remarks>
        </member>
        <member name="M:VDS.Common.Filters.IBloomFilter`1.Clear">
            <summary>
            Clears the bloom filter i.e. resets it to a state where it has seen no items
            </summary>
        </member>
        <member name="M:VDS.Common.Filters.BaseBloomFilter`1.#ctor(VDS.Common.Filters.IBloomFilterStorage)">
            <summary>
            Creates a new filter
            </summary>
            <param name="storage">Storage to use</param>
        </member>
        <member name="M:VDS.Common.Filters.BaseBloomFilter`1.GetBitIndices(`0)">
            <summary>
            Converts an item into a number of bit indexes
            </summary>
            <param name="item">Item</param>
            <returns>Bit Indices</returns>
        </member>
        <member name="M:VDS.Common.Filters.BaseBloomFilter`1.MayContain(`0)">
            <summary>
            Gets whether the filter may have already seen the given item
            </summary>
            <param name="item">Item</param>
            <returns>True if the item may have been seen, false otherwise</returns>
            <remarks>
            Bloom filters may return false positives hence why this method is named <strong>MayContain</strong> but they are guaranteed to never return false negatives
            </remarks>
        </member>
        <member name="M:VDS.Common.Filters.BaseBloomFilter`1.Clear">
            <summary>
            Clears the filter
            </summary>
        </member>
        <member name="M:VDS.Common.Filters.BaseBloomFilter`1.Add(`0)">
            <summary>
            Adds an item to the filter
            </summary>
            <param name="item">Item</param>
            <returns>True if the item was added to the filter, false if item may already have been present and was not added</returns>
        </member>
        <member name="P:VDS.Common.Filters.BaseBloomFilter`1.Storage">
            <summary>
            Gets the storage in use
            </summary>
        </member>
        <member name="T:VDS.Common.Filters.BaseHybridBloomFilter`1">
            <summary>
            Abstract implementation of a bloom filter
            </summary>
            <typeparam name="T"></typeparam>
            <remarks>
            This implementation is a hybrid of the naive and fast approaches provided by <see cref="T:VDS.Common.Filters.BaseNaiveBloomFilter`1"/> and <see cref="T:VDS.Common.Filters.BaseFastBloomFilter`1"/> in that it allows for users to provide more than two hash functions but uses the fast arithmetic technique to create any additional hash functions needed.
            </remarks>
        </member>
        <member name="M:VDS.Common.Filters.BaseHybridBloomFilter`1.#ctor(VDS.Common.Filters.IBloomFilterStorage,VDS.Common.Filters.IBloomFilterParameters,System.Collections.Generic.IEnumerable{System.Func{`0,System.Int32}})">
            <summary>
            Creates a new filter
            </summary>
            <param name="storage">Bloom Filter storage</param>
            <param name="parameters">Parameters</param>
            <param name="hashFunctions">Hash Functions</param>
        </member>
        <member name="M:VDS.Common.Filters.BaseHybridBloomFilter`1.GetBitIndices(`0)">
            <summary>
            Converts an item into a number of bit indexes
            </summary>
            <param name="item">Item</param>
            <returns>Bit Indices</returns>
        </member>
        <member name="P:VDS.Common.Filters.BaseHybridBloomFilter`1.NumberOfHashFunctions">
            <summary>
            Gets the number of hash functions
            </summary>
        </member>
        <member name="T:VDS.Common.Filters.BaseNaiveBloomFilter`1">
            <summary>
            Abstract implementation of a bloom filter
            </summary>
            <typeparam name="T"></typeparam>
            <remarks>
            This implementation is considered naive because it gives full control over the hash functions and number of bits to the end user
            </remarks>
        </member>
        <member name="M:VDS.Common.Filters.BaseNaiveBloomFilter`1.#ctor(VDS.Common.Filters.IBloomFilterStorage,System.Int32,System.Collections.Generic.IEnumerable{System.Func{`0,System.Int32}})">
            <summary>
            Creates a new filter
            </summary>
            <param name="storage">Bloom Filter storage</param>
            <param name="bits">Number of Bits</param>
            <param name="hashFunctions">Hash Functions</param>
        </member>
        <member name="M:VDS.Common.Filters.BaseNaiveBloomFilter`1.GetBitIndices(`0)">
            <summary>
            Converts an item into a number of bit indexes
            </summary>
            <param name="item">Item</param>
            <returns>Bit Indices</returns>
        </member>
        <member name="P:VDS.Common.Filters.BaseNaiveBloomFilter`1.NumberOfHashFunctions">
            <summary>
            Gets the number of hash functions
            </summary>
        </member>
        <member name="T:VDS.Common.Filters.BaseFastBloomFilter`1">
            <summary>
            Abstract implementation of a fast bloom filter using the methodology outlined in <a href="http://citeseer.ist.psu.edu/viewdoc/download?doi=10.1.1.152.579&amp;rep=rep1&amp;type=pdf">Less Hashing, Same Performance: Building a Better Bloom Filter</a>
            </summary>
            <typeparam name="T"></typeparam>
            <remarks>
            This implementation works on a technique described in the literature which shows that given two hash functions it is possible to simulate any number of hash functions by performing simple arithmetic combinations of the two hash functions outputs.  In practise this means that the hashing used by the bloom filter is significantly faster because it needs only calculate two hash functions for any given item and then can compute the necessary number of hash values by simple arithmetic operations.
            </remarks>
        </member>
        <member name="M:VDS.Common.Filters.BaseFastBloomFilter`1.#ctor(VDS.Common.Filters.IBloomFilterStorage,VDS.Common.Filters.IBloomFilterParameters,System.Func{`0,System.Int32},System.Func{`0,System.Int32})">
            <summary>
            Creates a new 
            </summary>
            <param name="storage">Bloom Filter Storage</param>
            <param name="parameters">Parameters</param>
            <param name="h1">First hash function</param>
            <param name="h2">Second hash function</param>
        </member>
        <member name="M:VDS.Common.Filters.BaseFastBloomFilter`1.GetBitIndices(`0)">
            <summary>
            Converts the item into a number of bit indices
            </summary>
            <param name="item">Item</param>
            <returns>Bit Indices</returns>
        </member>
        <member name="P:VDS.Common.Filters.BaseFastBloomFilter`1.NumberOfHashFunctions">
            <summary>
            Gets the number of hash functions
            </summary>
        </member>
        <member name="T:VDS.Common.Filters.BloomFilterParameters">
            <summary>
            Basic implementation of bloom filter parameters
            </summary>
        </member>
        <member name="M:VDS.Common.Filters.BloomFilterParameters.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates new parameters
            </summary>
            <param name="numBits">Number of bits</param>
            <param name="numHashFunctions">Number of hash functions</param>
        </member>
        <member name="P:VDS.Common.Filters.BloomFilterParameters.NumberOfHashFunctions">
            <summary>
            Gets the number of hash functions
            </summary>
        </member>
        <member name="T:VDS.Common.Filters.BloomUtils">
            <summary>
            Provides utility functions for working with bloom filters
            </summary>
        </member>
        <member name="M:VDS.Common.Filters.BloomUtils.CalculateBloomParameters(System.Int64,System.Int64)">
            <summary>
            Calculates the necessary parameters for a Bloom Filter
            </summary>
            <param name="expectedItems">Expected number of items that will be added to the filter</param>
            <param name="errorRate">Desired error rate, the value given is treated as a 1 in N error rate</param>
            <returns>Bloom Filter parameters</returns>
        </member>
        <member name="M:VDS.Common.Filters.BloomUtils.CalculateBloomParameters(System.Int64,System.Double)">
            <summary>
            Calculates the necessary parameters for a Bloom Filter
            </summary>
            <param name="expectedItems">Expected number of items that will be added to the filter</param>
            <param name="errorRate">Desired error rate given as a value between 0 and 1.0</param>
            <returns>Bloom Filter parameters</returns>
        </member>
        <member name="M:VDS.Common.Filters.BloomUtils.CalculateErrorRate(System.Int64,VDS.Common.Filters.IBloomFilterParameters)">
            <summary>
            Given some parameters and the expected number of items calculates the error rate
            </summary>
            <param name="expectedItems">Expected number of items that will be added to the filter</param>
            <param name="parameters">Bloom Filter Parameters</param>
            <returns>Error Rate as a value between 0 and 1.0</returns>
        </member>
        <member name="T:VDS.Common.Filters.FastBloomFilter`1">
            <summary>
            A fast bloom filter backed by an array
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:VDS.Common.Filters.FastBloomFilter`1.#ctor(VDS.Common.Filters.IBloomFilterParameters,System.Func{`0,System.Int32},System.Func{`0,System.Int32})">
            <summary>
            Creates a new filter
            </summary>
            <param name="parameters">Parameters</param>
            <param name="h1">Hash function 1</param>
            <param name="h2">Hash function 2</param>
        </member>
        <member name="T:VDS.Common.Filters.SparseHybridBloomFilter`1">
            <summary>
            A hybrid bloom filter backed by an array
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="M:VDS.Common.Filters.SparseHybridBloomFilter`1.#ctor(VDS.Common.Filters.IBloomFilterParameters,System.Collections.Generic.IEnumerable{System.Func{`0,System.Int32}})">
            <summary>
            Creates a new filter
            </summary>
            <param name="parameters">Parameters</param>
            <param name="hashFunctions">Hash functions</param>
        </member>
        <member name="T:VDS.Common.Filters.IBloomFilterStorage">
            <summary>
            Interface for bloom filter storage
            </summary>
        </member>
        <member name="M:VDS.Common.Filters.IBloomFilterStorage.IsSet(System.Int32)">
            <summary>
            Gets whether the given bit is set
            </summary>
            <param name="index">Index</param>
            <returns>True if set, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Filters.IBloomFilterStorage.Set(System.Int32)">
            <summary>
            Sets the given bit
            </summary>
            <param name="index">Index</param>
        </member>
        <member name="M:VDS.Common.Filters.IBloomFilterStorage.Clear">
            <summary>
            Clears the storage i.e. unsets all the bits
            </summary>
        </member>
        <member name="T:VDS.Common.Filters.HybridBloomFilter`1">
            <summary>
            A hybrid bloom filter backed by an array
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="M:VDS.Common.Filters.HybridBloomFilter`1.#ctor(VDS.Common.Filters.IBloomFilterParameters,System.Collections.Generic.IEnumerable{System.Func{`0,System.Int32}})">
            <summary>
            Creates a new filter
            </summary>
            <param name="parameters">Parameters</param>
            <param name="hashFunctions">Hash functions</param>
        </member>
        <member name="T:VDS.Common.Filters.NaiveBloomFilter`1">
            <summary>
            A naive bloom filter backed by an array
            </summary>
            <typeparam name="T">Item type</typeparam>
            <remarks>
            This implementation is considered naive because it is entirely configured by the end user, consider using the <see cref="T:VDS.Common.Filters.FastBloomFilter`1"/> which uses a much better hashing approach that is faster and more robust
            </remarks>
        </member>
        <member name="M:VDS.Common.Filters.NaiveBloomFilter`1.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Func{`0,System.Int32}})">
            <summary>
            Creates a new filter
            </summary>
            <param name="bits">Number of bits</param>
            <param name="hashFunctions">Hash functions</param>
        </member>
        <member name="T:VDS.Common.Filters.SparseFastBloomFilter`1">
            <summary>
            Bloom filter implementation backed by a <see cref="T:VDS.Common.Collections.ISparseArray`1"/>
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="M:VDS.Common.Filters.SparseFastBloomFilter`1.#ctor(VDS.Common.Filters.IBloomFilterParameters,System.Func{`0,System.Int32},System.Func{`0,System.Int32})">
            <summary>
            Creates a new filter
            </summary>
            <param name="parameters">Parameters</param>
            <param name="h1">Hash function 1</param>
            <param name="h2">Hash function 2</param>
        </member>
        <member name="T:VDS.Common.Filters.SparseNaiveBloomFilter`1">
            <summary>
            Bloom filter implementation backed by a <see cref="T:VDS.Common.Collections.ISparseArray`1"/>
            </summary>
            <typeparam name="T">Item type</typeparam>
        </member>
        <member name="M:VDS.Common.Filters.SparseNaiveBloomFilter`1.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Func{`0,System.Int32}})">
            <summary>
            Creates a new filter
            </summary>
            <param name="bits">Number of bits</param>
            <param name="hashFunctions">Hash functions</param>
        </member>
        <member name="T:VDS.Common.Filters.Storage.ArrayStorage">
            <summary>
            Array based storage for Bloom Filters
            </summary>
        </member>
        <member name="M:VDS.Common.Filters.Storage.ArrayStorage.#ctor(System.Int32)">
            <summary>
            Creates new array storage
            </summary>
            <param name="size">Size in bits of the storage</param>
        </member>
        <member name="M:VDS.Common.Filters.Storage.ArrayStorage.IsSet(System.Int32)">
            <summary>
            Gets whether a given bit is set
            </summary>
            <param name="index">Index</param>
            <returns>True if set, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Filters.Storage.ArrayStorage.Set(System.Int32)">
            <summary>
            Sets a given bit
            </summary>
            <param name="index">Index</param>
        </member>
        <member name="M:VDS.Common.Filters.Storage.ArrayStorage.Clear">
            <summary>
            Clears the storage
            </summary>
        </member>
        <member name="T:VDS.Common.Filters.Storage.SparseArrayStorage">
            <summary>
            A sparse array storage implementation for bloom filters
            </summary>
        </member>
        <member name="M:VDS.Common.Filters.Storage.SparseArrayStorage.#ctor(VDS.Common.Filters.IBloomFilterParameters)">
            <summary>
            Creates new storage
            </summary>
            <param name="parameters">Parameters</param>
        </member>
        <member name="M:VDS.Common.Filters.Storage.SparseArrayStorage.#ctor(VDS.Common.Collections.ISparseArray{System.Boolean})">
            <summary>
            Creates new storage
            </summary>
            <param name="bits">Sparse array to use as storage</param>
        </member>
        <member name="M:VDS.Common.Filters.Storage.SparseArrayStorage.IsSet(System.Int32)">
            <summary>
            Gets whether a given bit is set
            </summary>
            <param name="index">Index</param>
            <returns>True if set, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Filters.Storage.SparseArrayStorage.Set(System.Int32)">
            <summary>
            Sets a given bit
            </summary>
            <param name="index">Index</param>
        </member>
        <member name="M:VDS.Common.Filters.Storage.SparseArrayStorage.Clear">
            <summary>
            Clears the storage
            </summary>
        </member>
        <member name="T:VDS.Common.References.NestedReference`1">
            <summary>
            Represents a reference whose value may change based on nesting level
            </summary>
            <typeparam name="T">Reference Type</typeparam>
        </member>
        <member name="M:VDS.Common.References.NestedReference`1.#ctor">
            <summary>
            Creates a new Nested Reference with an initial null value
            </summary>
        </member>
        <member name="M:VDS.Common.References.NestedReference`1.#ctor(`0)">
            <summary>
            Creates a new nested reference with an initial value
            </summary>
            <param name="initValue">Initial Value</param>
        </member>
        <member name="M:VDS.Common.References.NestedReference`1.IncrementNesting">
            <summary>
            Increments the nesting level
            </summary>
        </member>
        <member name="M:VDS.Common.References.NestedReference`1.DecrementNesting">
            <summary>
            Decrements the nesting level
            </summary>
        </member>
        <member name="P:VDS.Common.References.NestedReference`1.Value">
            <summary>
            Gets/Sets the value based on the current nesting level
            </summary>
        </member>
        <member name="T:VDS.Common.References.ThreadIsolatedReference`1">
            <summary>
            Provides a thread isolated reference to some reference type
            </summary>
            <typeparam name="T">Reference Type</typeparam>
            <remarks>
            <para>
            Essentially the ThreadIsolatedReference guarantees that each thread that accesses it sees a thread-specific view of the reference.  The initial value of the reference for each Thread is generated either by an initialiser function passed to the constructor when the ThreadSafeReference is created or otherwise is null.  This is essentially what the <see cref="T:System.Threading.ThreadLocal`1"/> introduced in .Net 4.0 does but we continue to use this our own wrapper because we need backwards compatibility with .Net 3.5 and ThreadLocal does not play quite right with some of our usage patterns
            </para>
            </remarks>
        </member>
        <member name="M:VDS.Common.References.ThreadIsolatedReference`1.#ctor">
            <summary>
            Creates a new ThreadSafeReference where the initial value of the reference on each thread is null
            </summary>
        </member>
        <member name="M:VDS.Common.References.ThreadIsolatedReference`1.#ctor(System.Func{`0})">
            <summary>
            Creates a new ThreadSafeReference where the initial value of the reference on each thread is generated by the given initialiser function
            </summary>
            <param name="init">Initialiser Function</param>
        </member>
        <member name="M:VDS.Common.References.ThreadIsolatedReference`1.Dispose">
            <summary>
            Disposes of a Thread Safe reference
            </summary>
            <remarks>
            Does not take any dispose actions on the references it holds, it will drop those so the GC can collect them as desired.  This also avoids any unintended consequences of a dispose on one thread causing strange behaviour on another
            </remarks>
        </member>
        <member name="P:VDS.Common.References.ThreadIsolatedReference`1.Initialiser">
            <summary>
            Gets the initialiser function
            </summary>
        </member>
        <member name="P:VDS.Common.References.ThreadIsolatedReference`1.Value">
            <summary>
            Gets/Sets the value for the current thread
            </summary>
        </member>
        <member name="T:VDS.Common.References.ThreadIsolatedValue`1">
            <summary>
            Provides a thread isolated reference to some value type
            </summary>
            <typeparam name="T">Reference Type</typeparam>
        </member>
        <member name="M:VDS.Common.References.ThreadIsolatedValue`1.#ctor">
            <summary>
            Creates a new ThreadSafeValue where the initial value of the struct on each thread is default
            </summary>
        </member>
        <member name="M:VDS.Common.References.ThreadIsolatedValue`1.#ctor(System.Func{`0})">
            <summary>
            Creates a new ThreadSafeValue where the initial value of the struct on each thread is generated by the given initialiser function
            </summary>
            <param name="init">Initialiser Function</param>
        </member>
        <member name="M:VDS.Common.References.ThreadIsolatedValue`1.Dispose">
            <summary>
            Disposes of the value
            </summary>
        </member>
        <member name="P:VDS.Common.References.ThreadIsolatedValue`1.Initialiser">
            <summary>
            Gets the initialiser function
            </summary>
        </member>
        <member name="P:VDS.Common.References.ThreadIsolatedValue`1.Value">
            <summary>
            Gets/Sets the value for the current thread
            </summary>
        </member>
        <member name="T:VDS.Common.Trees.AVLTree`2">
            <summary>
            An AVL tree implementation
            </summary>
            <typeparam name="TKey">Key Type</typeparam>
            <typeparam name="TValue">Valye Type</typeparam>
            <remarks>
            <para>
            Code based in part on various examples from around the web including (but not limited to) <a href="http://www.vcskicks.com/AVL-tree.php">VCSKicks</a> and <a href="http://en.wikipedia.org/wiki/AVL_tree">Wikipedia</a>
            </para>
            </remarks>
        </member>
        <member name="T:VDS.Common.Trees.BinaryTree`2">
            <summary>
            Abstract base implementation of an unbalanced binary search tree
            </summary>
            <typeparam name="TKey">Key Type</typeparam>
            <typeparam name="TValue">Value Type</typeparam>
        </member>
        <member name="T:VDS.Common.Trees.IBinaryTree`2">
            <summary>
            Interface for binary trees
            </summary>
            <typeparam name="TKey">Key type</typeparam>
            <typeparam name="TValue">Value type</typeparam>
        </member>
        <member name="T:VDS.Common.Trees.IIndexAccessTree`3">
            <summary>
            Interface for trees that support indexed access
            </summary>
            <remarks>
            Indexes may not be stable depending on the underlying tree type
            </remarks>
            <typeparam name="TNode">Node type</typeparam>
            <typeparam name="TKey">Key type</typeparam>
            <typeparam name="TValue">Value type</typeparam>
        </member>
        <member name="T:VDS.Common.Trees.ITree`3">
            <summary>
            Interface for Trees
            </summary>
            <typeparam name="TNode">Node Type</typeparam>
            <typeparam name="TKey">Key Type</typeparam>
            <typeparam name="TValue">Value Type</typeparam>
            <remarks>
            A Tree is a mapping from keys to values stored in a tree structure, individual implementations control how the tree is stored and navigated
            </remarks>
        </member>
        <member name="M:VDS.Common.Trees.ITree`3.Add(`1,`2)">
            <summary>
            Adds a Key Value pair to the tree or replaces the existing value associated with a key
            </summary>
            <param name="key">Key</param>
            <param name="value">Value</param>
            <returns>True if a new node was created, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">Thrown if a duplicate key is added</exception>
        </member>
        <member name="M:VDS.Common.Trees.ITree`3.Find(`1)">
            <summary>
            Finds a Node based on the key
            </summary>
            <param name="key">Key</param>
            <returns>Node associated with the given Key or null if the key is not present in the tree</returns>
        </member>
        <member name="M:VDS.Common.Trees.ITree`3.MoveToNode(`1,System.Boolean@)">
            <summary>
            Moves to a Node based on the key inserting a new Node if necessary
            </summary>
            <param name="key">Key</param>
            <param name="created">Whether a new node was inserted</param>
            <returns>Node associated with the given Key which may be newly inserted</returns>
        </member>
        <member name="M:VDS.Common.Trees.ITree`3.Remove(`1)">
            <summary>
            Removes a Node based on the Key
            </summary>
            <param name="key">Key</param>
            <returns>True if a Node was removed</returns>
        </member>
        <member name="M:VDS.Common.Trees.ITree`3.ContainsKey(`1)">
            <summary>
            Determines whether a given Key exists in the Tree
            </summary>
            <param name="key">Key</param>
            <returns>True if the key exists in the Tree</returns>
        </member>
        <member name="M:VDS.Common.Trees.ITree`3.TryGetValue(`1,`2@)">
            <summary>
            Tries to get a value based on a key
            </summary>
            <param name="key">Key</param>
            <param name="value">Value or default for the value type if the key is not present</param>
            <returns>True if there is a value associated with the key</returns>
        </member>
        <member name="M:VDS.Common.Trees.ITree`3.Clear">
            <summary>
            Empty the tree
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.ITree`3.Root">
            <summary>
            Gets the root of the tree
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.ITree`3.Item(`1)">
            <summary>
            Gets/Sets the value for a key
            </summary>
            <param name="key">Key</param>
            <returns>Returns the value associated with the key</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the key doesn't exist</exception>
        </member>
        <member name="P:VDS.Common.Trees.ITree`3.Nodes">
            <summary>
            Gets the Nodes of the tree
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.ITree`3.Keys">
            <summary>
            Gets the keys in the tree
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.ITree`3.Values">
            <summary>
            Gets the values in the tree
            </summary>
        </member>
        <member name="M:VDS.Common.Trees.IIndexAccessTree`3.GetValueAt(System.Int32)">
            <summary>
            Gets the value at the given index
            </summary>
            <param name="index">Index</param>
            <returns>Value at the given index</returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if the index is not within the acceptable range for this tree</exception>
        </member>
        <member name="M:VDS.Common.Trees.IIndexAccessTree`3.SetValueAt(System.Int32,`2)">
            <summary>
            Sets the value at the given index
            </summary>
            <param name="index">Index</param>
            <param name="value">Value</param>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if the index is not within the acceptable range for this tree</exception>
        </member>
        <member name="M:VDS.Common.Trees.IIndexAccessTree`3.RemoveAt(System.Int32)">
            <summary>
            Removes the value (and corresponding key) at the given index
            </summary>
            <param name="index">Index</param>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if the index is not within the acceptable range for this tree</exception>
        </member>
        <member name="F:VDS.Common.Trees.BinaryTree`2._comparer">
            <summary>
            Key Comparer
            </summary>
        </member>
        <member name="M:VDS.Common.Trees.BinaryTree`2.#ctor">
            <summary>
            Creates a new unbalanced Binary Tree
            </summary>
        </member>
        <member name="M:VDS.Common.Trees.BinaryTree`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new unbalanced Binary Tree
            </summary>
            <param name="comparer">Comparer for keys</param>
        </member>
        <member name="M:VDS.Common.Trees.BinaryTree`2.Add(`0,`1)">
            <summary>
            Adds a Key Value pair to the tree, replaces an existing value if the key already exists in the tree
            </summary>
            <param name="key">Key</param>
            <param name="value">Value</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException">Thrown if a duplicate key is used</exception>
        </member>
        <member name="M:VDS.Common.Trees.BinaryTree`2.CreateNode(VDS.Common.Trees.IBinaryTreeNode{`0,`1},`0,`1)">
            <summary>
            Creates a new node for the tree
            </summary>
            <param name="parent">Parent node</param>
            <param name="key">Key</param>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Trees.BinaryTree`2.Find(`0)">
            <summary>
            Finds a Node based on the key
            </summary>
            <param name="key">Key</param>
            <returns>Node associated with the given Key or null if the key is not present in the tree</returns>
        </member>
        <member name="M:VDS.Common.Trees.BinaryTree`2.MoveToNode(`0,System.Boolean@)">
            <summary>
            Moves to the node with the given key inserting a new node if necessary
            </summary>
            <param name="key">Key</param>
            <param name="created">Whether a new node was inserted</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Trees.BinaryTree`2.AfterLeftInsert(VDS.Common.Trees.IBinaryTreeNode{`0,`1},VDS.Common.Trees.IBinaryTreeNode{`0,`1})">
            <summary>
            Virtual method that can be used by derived implementations to perform tree balances after an insert
            </summary>
            <param name="parent">Parent</param>
            <param name="node">Newly inserted node</param>
        </member>
        <member name="M:VDS.Common.Trees.BinaryTree`2.AfterRightInsert(VDS.Common.Trees.IBinaryTreeNode{`0,`1},VDS.Common.Trees.IBinaryTreeNode{`0,`1})">
            <summary>
            Virtual method that can be used by derived implementations to perform tree balances after an insert
            </summary>
            <param name="parent">Parent</param>
            <param name="node">Newly inserted node</param>
        </member>
        <member name="M:VDS.Common.Trees.BinaryTree`2.Remove(`0)">
            <summary>
            Removes a Node based on the Key
            </summary>
            <param name="key">Key</param>
            <returns>True if a Node was removed</returns>
        </member>
        <member name="M:VDS.Common.Trees.BinaryTree`2.RemoveNode(VDS.Common.Trees.IBinaryTreeNode{`0,`1},System.Int32)">
            <summary>
            Removes a node
            </summary>
            <param name="current">Node to be removed</param>
            <param name="c">Comparison of this node versus its parent</param>
            <returns>True if node removed</returns>
        </member>
        <member name="M:VDS.Common.Trees.BinaryTree`2.AfterDelete(VDS.Common.Trees.IBinaryTreeNode{`0,`1})">
            <summary>
            Virtual method that can be used by derived implementations to perform tree balances after a delete
            </summary>
            <param name="node">Node at which the deletion happened</param>
        </member>
        <member name="M:VDS.Common.Trees.BinaryTree`2.ContainsKey(`0)">
            <summary>
            Determines whether a given Key exists in the Tree
            </summary>
            <param name="key">Key</param>
            <returns>True if the key exists in the Tree</returns>
        </member>
        <member name="M:VDS.Common.Trees.BinaryTree`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to get a value based on a key
            </summary>
            <param name="key">Key</param>
            <param name="value">Value or default for the value type if the key is not present</param>
            <returns>True if there is a value associated with the key</returns>
        </member>
        <member name="M:VDS.Common.Trees.BinaryTree`2.MoveToIndex(System.Int32)">
            <summary>
            Tries to move to a node based on its index
            </summary>
            <param name="index">Index</param>
            <returns>Node</returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if the index is out of range</exception>
        </member>
        <member name="M:VDS.Common.Trees.BinaryTree`2.GetValueAt(System.Int32)">
            <summary>
            Gets the value at the given index
            </summary>
            <param name="index">Index</param>
            <returns>Value</returns>
        </member>
        <member name="M:VDS.Common.Trees.BinaryTree`2.SetValueAt(System.Int32,`1)">
            <summary>
            Sets the value at the given index
            </summary>
            <param name="index">Index</param>
            <param name="value">Value</param>
        </member>
        <member name="M:VDS.Common.Trees.BinaryTree`2.RemoveAt(System.Int32)">
            <summary>
            Removes the key-value pair at the given index
            </summary>
            <param name="index">Index</param>
        </member>
        <member name="M:VDS.Common.Trees.BinaryTree`2.Clear">
            <summary>
            Clears the tree
            </summary>
        </member>
        <member name="M:VDS.Common.Trees.BinaryTree`2.AfterClear">
            <summary>
            Virtual method that can be used by derived implementations to perform clean up after a clear
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.BinaryTree`2.Root">
            <summary>
            Gets/Sets the Root of the Tree
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.BinaryTree`2.Item(`0)">
            <summary>
            Gets/Sets the value for a key
            </summary>
            <param name="key">Key</param>
            <returns>Returns the value associated with the key</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the key doesn't exist</exception>
        </member>
        <member name="P:VDS.Common.Trees.BinaryTree`2.Nodes">
            <summary>
            Gets the Nodes of the Tree
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.BinaryTree`2.Keys">
            <summary>
            Gets the Keys of the Tree
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.BinaryTree`2.Values">
            <summary>
            Gets the Values of the Tree
            </summary>
        </member>
        <member name="M:VDS.Common.Trees.AVLTree`2.#ctor">
            <summary>
            Creates a new AVL Tree
            </summary>
        </member>
        <member name="M:VDS.Common.Trees.AVLTree`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new AVL Tree using the given key comparer
            </summary>
            <param name="comparer">Key Comparer</param>
        </member>
        <member name="M:VDS.Common.Trees.AVLTree`2.CreateNode(VDS.Common.Trees.IBinaryTreeNode{`0,`1},`0,`1)">
            <summary>
            Creates a new node
            </summary>
            <param name="parent">Parent Node</param>
            <param name="key">Key</param>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Trees.AVLTree`2.AfterLeftInsert(VDS.Common.Trees.IBinaryTreeNode{`0,`1},VDS.Common.Trees.IBinaryTreeNode{`0,`1})">
            <summary>
            Applies rebalances after inserts
            </summary>
            <param name="parent">Parent</param>
            <param name="node">Newly isnerted node</param>
        </member>
        <member name="M:VDS.Common.Trees.AVLTree`2.AfterRightInsert(VDS.Common.Trees.IBinaryTreeNode{`0,`1},VDS.Common.Trees.IBinaryTreeNode{`0,`1})">
            <summary>
            Applies rebalances after inserts
            </summary>
            <param name="parent">Parent</param>
            <param name="node">Newly isnerted node</param>
        </member>
        <member name="M:VDS.Common.Trees.AVLTree`2.RebalanceAfterInsert(VDS.Common.Trees.IBinaryTreeNode{`0,`1})">
            <summary>
            Applies rebalances after inserts
            </summary>
            <param name="node">Newly isnerted node</param>
        </member>
        <member name="M:VDS.Common.Trees.AVLTree`2.AfterDelete(VDS.Common.Trees.IBinaryTreeNode{`0,`1})">
            <summary>
            Applies rebalances after deletes
            </summary>
            <param name="node">Node at which the delete occurred</param>
        </member>
        <member name="M:VDS.Common.Trees.AVLTree`2.Rebalance(VDS.Common.Trees.IBinaryTreeNode{`0,`1},System.Int64)">
            <summary>
            Applies tree rebalances
            </summary>
            <param name="node">Node</param>
            <param name="balance">Balance at the Node</param>
        </member>
        <member name="M:VDS.Common.Trees.AVLTree`2.RotateLeft(VDS.Common.Trees.IBinaryTreeNode{`0,`1})">
            <summary>
            Applies left rotation
            </summary>
            <param name="node">Node</param>
        </member>
        <member name="M:VDS.Common.Trees.AVLTree`2.RotateRight(VDS.Common.Trees.IBinaryTreeNode{`0,`1})">
            <summary>
            Applies right rotation
            </summary>
            <param name="node">Node</param>
        </member>
        <member name="T:VDS.Common.Trees.BinaryTreeNode`2">
            <summary>
            Binary Tree node implementation
            </summary>
            <typeparam name="TKey">Key Type</typeparam>
            <typeparam name="TValue">Value Type</typeparam>
        </member>
        <member name="T:VDS.Common.Trees.IBinaryTreeNode`2">
            <summary>
            Interface for Binary Tree Nodes
            </summary>
            <typeparam name="TKey">Key Type</typeparam>
            <typeparam name="TValue">Value Type</typeparam>
        </member>
        <member name="T:VDS.Common.Trees.ITreeNode`2">
            <summary>
            Interface for Tree Nodes
            </summary>
            <typeparam name="TKey">Key Type</typeparam>
            <typeparam name="TValue">Value Type</typeparam>
        </member>
        <member name="P:VDS.Common.Trees.ITreeNode`2.Key">
            <summary>
            Gets/Sets the key associated with the node
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.ITreeNode`2.Value">
            <summary>
            Gets/Sets the value associated with the node
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.ITreeNode`2.HasChildren">
            <summary>
            Gets whether the node has children
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.ITreeNode`2.ChildCount">
            <summary>
            Gets whether the number of child nodes
            </summary>
        </member>
        <member name="M:VDS.Common.Trees.IBinaryTreeNode`2.RecalculateHeight">
            <summary>
            Indicates that the node should recalculate the height of the subtree it represents
            </summary>
        </member>
        <member name="M:VDS.Common.Trees.IBinaryTreeNode`2.RecalculateSize">
            <summary>
            Indicates that the node should recalculate the size of the subtree it represents
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.IBinaryTreeNode`2.LeftChild">
            <summary>
            Gets the left child of this node
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.IBinaryTreeNode`2.RightChild">
            <summary>
            Gets the right child of this node
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.IBinaryTreeNode`2.Parent">
            <summary>
            Gets the parent of the node
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.IBinaryTreeNode`2.Nodes">
            <summary>
            Gets the nodes present for the entire subtree (including this node)
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.IBinaryTreeNode`2.Height">
            <summary>
            Gets the Height of the subtree this node represents
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.IBinaryTreeNode`2.Size">
            <summary>
            Gets the size of the subtree this node represents i.e. number of nodes including this node
            </summary>
        </member>
        <member name="M:VDS.Common.Trees.BinaryTreeNode`2.#ctor(VDS.Common.Trees.IBinaryTreeNode{`0,`1},`0,`1)">
            <summary>
            Creates a new Binary Tree Node
            </summary>
            <param name="parent">Parent</param>
            <param name="key">Key</param>
            <param name="value">Value</param>
        </member>
        <member name="M:VDS.Common.Trees.BinaryTreeNode`2.RecalculateHeight">
            <summary>
            Recalculates the height of the subtree
            </summary>
        </member>
        <member name="M:VDS.Common.Trees.BinaryTreeNode`2.RecalculateSize">
            <summary>
            Recalculates the size of the subtree
            </summary>
        </member>
        <member name="M:VDS.Common.Trees.BinaryTreeNode`2.ToString">
            <summary>
            Gets a String representation of the node
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.Common.Trees.BinaryTreeNode`2.Parent">
            <summary>
            Gets/Sets the Parent Node (if any)
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.BinaryTreeNode`2.LeftChild">
            <summary>
            Gets/Sets the Left Child (if any)
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.BinaryTreeNode`2.RightChild">
            <summary>
            Gets/Sets the Right Child (if any)
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.BinaryTreeNode`2.Key">
            <summary>
            Gets/Sets the Key
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.BinaryTreeNode`2.Value">
            <summary>
            Gets/Sets the Value
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.BinaryTreeNode`2.HasChildren">
            <summary>
            Gets whether this Node has children
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.BinaryTreeNode`2.ChildCount">
            <summary>
            Gets the number of child nodes present (0, or 1)
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.BinaryTreeNode`2.Height">
            <summary>
            Gets the height of the subtree
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.BinaryTreeNode`2.Size">
            <summary>
            Gets the size of the subtree i.e. number of nodes including this node in the count
            </summary>
        </member>
        <member name="P:VDS.Common.Trees.BinaryTreeNode`2.Nodes">
            <summary>
            Gets the nodes of the subtree including this node
            </summary>
        </member>
        <member name="T:VDS.Common.Trees.NodesEnumerable`3">
            <summary>
            An enumerable over a binary tree which ensures that each time it is enumeraeted the latest state of the tree is enumerated
            </summary>
            <typeparam name="TNode">Node type</typeparam>
            <typeparam name="TKey">Key type</typeparam>
            <typeparam name="TValue">Value type</typeparam>
        </member>
        <member name="M:VDS.Common.Trees.NodesEnumerable`3.#ctor(VDS.Common.Trees.IBinaryTree{`1,`2})">
            <summary>
            Creates a new nodes enumerable for a binary tree
            </summary>
            <param name="tree">Binary Tree</param>
        </member>
        <member name="M:VDS.Common.Trees.NodesEnumerable`3.GetEnumerator">
            <summary>
            Gets an enumerator over the current state of the tree
            </summary>
            <returns>Enumerator over nodes</returns>
        </member>
        <member name="M:VDS.Common.Trees.NodesEnumerable`3.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator over the current state of the tree
            </summary>
            <returns>Enumerator over nodes</returns>
        </member>
        <member name="T:VDS.Common.Trees.ChildNodesEnumerable`2">
            <summary>
            An enumerable over a binary tree nodes children which ensures that each time it is enumerated the latest state of the tree is enumerated
            </summary>
            <typeparam name="TKey">Key type</typeparam>
            <typeparam name="TValue">Value type</typeparam>
        </member>
        <member name="F:VDS.Common.Trees.ChildNodesEnumerable`2._parent">
            <summary>
            Parent node
            </summary>
        </member>
        <member name="M:VDS.Common.Trees.ChildNodesEnumerable`2.#ctor(VDS.Common.Trees.IBinaryTreeNode{`0,`1})">
            <summary>
            Creates a new enumerable
            </summary>
            <param name="parent">Parent node</param>
        </member>
        <member name="M:VDS.Common.Trees.ChildNodesEnumerable`2.GetEnumerator">
            <summary>
            Gets an enumerator over the current state of one of the nodes children
            </summary>
            <returns>Enumerator over nodes</returns>
        </member>
        <member name="M:VDS.Common.Trees.ChildNodesEnumerable`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator over the current state of one of the nodes children
            </summary>
            <returns>Enumerator over nodes</returns>
        </member>
        <member name="P:VDS.Common.Trees.ChildNodesEnumerable`2.Child">
            <summary>
            Get the child whose nodes we want to enumerate
            </summary>
        </member>
        <member name="T:VDS.Common.Trees.LeftChildNodeEnumerable`2">
            <summary>
            An enumerable over the left child of a binary tree node which ensures that each time it is enumerated the latest state of the tree is enumerated
            </summary>
            <typeparam name="TKey">Key type</typeparam>
            <typeparam name="TValue">Value type</typeparam>
        </member>
        <member name="M:VDS.Common.Trees.LeftChildNodeEnumerable`2.#ctor(VDS.Common.Trees.IBinaryTreeNode{`0,`1})">
            <summary>
            Creates a new enumerable
            </summary>
            <param name="parent">Parent node</param>
        </member>
        <member name="P:VDS.Common.Trees.LeftChildNodeEnumerable`2.Child">
            <summary>
            Gets the left child
            </summary>
        </member>
        <member name="T:VDS.Common.Trees.RightChildNodeEnumerable`2">
            <summary>
            An enumerable over the right child of a binary tree node which ensures that each time it is enumerated the latest state of the tree is enumerated
            </summary>
            <typeparam name="TKey">Key type</typeparam>
            <typeparam name="TValue">Value type</typeparam>
        </member>
        <member name="M:VDS.Common.Trees.RightChildNodeEnumerable`2.#ctor(VDS.Common.Trees.IBinaryTreeNode{`0,`1})">
            <summary>
            Creates a new enumerable
            </summary>
            <param name="parent">Parent node</param>
        </member>
        <member name="P:VDS.Common.Trees.RightChildNodeEnumerable`2.Child">
            <summary>
            Gets the right child
            </summary>
        </member>
        <member name="T:VDS.Common.Trees.ScapegoatTree`2">
            <summary>
            A scapegoat tree implementation
            </summary>
            <typeparam name="TKey">Key Type</typeparam>
            <typeparam name="TValue">Valye Type</typeparam>
        </member>
        <member name="M:VDS.Common.Trees.ScapegoatTree`2.#ctor">
            <summary>
            Creates a new Scapegoat Tree
            </summary>
        </member>
        <member name="M:VDS.Common.Trees.ScapegoatTree`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new Scapegoat Tree
            </summary>
            <param name="comparer">Key Comparer</param>
        </member>
        <member name="M:VDS.Common.Trees.ScapegoatTree`2.#ctor(System.Double)">
            <summary>
            Creates a new Scapegoat Tree
            </summary>
            <param name="balanceFactor">Balance Factor</param>
        </member>
        <member name="M:VDS.Common.Trees.ScapegoatTree`2.#ctor(System.Collections.Generic.IComparer{`0},System.Double)">
            <summary>
            Creates a new Scapegoat Tree
            </summary>
            <param name="comparer">Key Comparer</param>
            <param name="balanceFactor">Balance Factor</param>
        </member>
        <member name="M:VDS.Common.Trees.ScapegoatTree`2.CreateNode(VDS.Common.Trees.IBinaryTreeNode{`0,`1},`0,`1)">
            <summary>
            Creates a new Node
            </summary>
            <param name="parent">Parent</param>
            <param name="key">Key</param>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Trees.ScapegoatTree`2.AfterLeftInsert(VDS.Common.Trees.IBinaryTreeNode{`0,`1},VDS.Common.Trees.IBinaryTreeNode{`0,`1})">
            <summary>
            Applies rebalances after left inserts
            </summary>
            <param name="parent">Parent</param>
            <param name="node">Newly inserted nodes</param>
        </member>
        <member name="M:VDS.Common.Trees.ScapegoatTree`2.AfterRightInsert(VDS.Common.Trees.IBinaryTreeNode{`0,`1},VDS.Common.Trees.IBinaryTreeNode{`0,`1})">
            <summary>
            Applies rebalances after right inserts
            </summary>
            <param name="parent">Parent</param>
            <param name="node">Newly inserted nodes</param>
        </member>
        <member name="M:VDS.Common.Trees.ScapegoatTree`2.RebalanceAfterInsert(VDS.Common.Trees.IBinaryTreeNode{`0,`1})">
            <summary>
            Applies rebalances after inserts
            </summary>
            <param name="node">Newly inserted node</param>
        </member>
        <member name="M:VDS.Common.Trees.ScapegoatTree`2.RebalanceAfterDelete(VDS.Common.Trees.IBinaryTreeNode{`0,`1})">
            <summary>
            Applies rebalances after deletes
            </summary>
            <param name="node">Node the delete occurred at</param>
        </member>
        <member name="M:VDS.Common.Trees.ScapegoatTree`2.Rebalance(VDS.Common.Trees.IBinaryTreeNode{`0,`1},System.Int64)">
            <summary>
            Applies rebalances
            </summary>
            <param name="node">Node</param>
            <param name="selfSize">Size of the subtree the node represents</param>
        </member>
        <member name="M:VDS.Common.Trees.ScapegoatTree`2.RebalanceLeftSubtree(VDS.Common.Trees.IBinaryTreeNode{`0,`1}[],System.Int32,System.Int32)">
            <summary>
            Rebalances a left subtree
            </summary>
            <param name="nodes">Nodes</param>
            <param name="start">Range start</param>
            <param name="end">Range end</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Trees.ScapegoatTree`2.RebalanceRightSubtree(VDS.Common.Trees.IBinaryTreeNode{`0,`1}[],System.Int32,System.Int32)">
            <summary>
            Rebalances a right subtree
            </summary>
            <param name="nodes">Nodes</param>
            <param name="start">Range start</param>
            <param name="end">Range end</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Trees.ScapegoatTree`2.AfterDelete(VDS.Common.Trees.IBinaryTreeNode{`0,`1})">
            <summary>
            Applies rebalances after deletes
            </summary>
            <param name="node">Node the delete occurred at</param>
        </member>
        <member name="M:VDS.Common.Trees.ScapegoatTree`2.AfterClear">
            <summary>
            Resets node counts after a clear
            </summary>
        </member>
        <member name="T:VDS.Common.Trees.TreeExtensions">
            <summary>
            Useful extensions for working with Trees
            </summary>
        </member>
        <member name="M:VDS.Common.Trees.TreeExtensions.GetDepth``2(VDS.Common.Trees.IBinaryTreeNode{``0,``1})">
            <summary>
            Gets the depth of the given node in the Tree
            </summary>
            <typeparam name="TKey">Key Type</typeparam>
            <typeparam name="TValue">Value Type</typeparam>
            <param name="node">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Trees.TreeExtensions.GetHeight``2(VDS.Common.Trees.IBinaryTreeNode{``0,``1})">
            <summary>
            Gets the Height of the given node in the Tree
            </summary>
            <typeparam name="TKey">Key</typeparam>
            <typeparam name="TValue">Value</typeparam>
            <param name="node">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Trees.TreeExtensions.GetBalance``2(VDS.Common.Trees.IBinaryTreeNode{``0,``1})">
            <summary>
            Gets the balance of the given node in the Tree
            </summary>
            <typeparam name="TKey">Key Type</typeparam>
            <typeparam name="TValue">Value Type</typeparam>
            <param name="node">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Trees.TreeExtensions.GetSibling``2(VDS.Common.Trees.IBinaryTreeNode{``0,``1})">
            <summary>
            Gets the sibling of a binary tree node (if any)
            </summary>
            <typeparam name="TKey">Key Type</typeparam>
            <typeparam name="TValue">Value Type</typeparam>
            <param name="node">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Trees.TreeExtensions.GetSize``2(VDS.Common.Trees.IBinaryTreeNode{``0,``1})">
            <summary>
            Gets the size of the subtree rooted at the given node
            </summary>
            <typeparam name="TKey">Key</typeparam>
            <typeparam name="TValue">Valye</typeparam>
            <param name="node">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Trees.TreeExtensions.Isolate``2(VDS.Common.Trees.IBinaryTreeNode{``0,``1})">
            <summary>
            Isolates a Node from the tree by setting its parent and child links to be null
            </summary>
            <typeparam name="TKey">Key Type</typeparam>
            <typeparam name="TValue">Valye Type</typeparam>
            <param name="node">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Trees.TreeExtensions.FindLeftmostChild``2(VDS.Common.Trees.IBinaryTreeNode{``0,``1})">
            <summary>
            Finds the leftmost child of the given node
            </summary>
            <param name="node">Node</param>
            <returns>Leftmost child or self if no left children</returns>
        </member>
        <member name="M:VDS.Common.Trees.TreeExtensions.FindRightmostChild``2(VDS.Common.Trees.IBinaryTreeNode{``0,``1})">
            <summary>
            Finds the rightmost child of the given node
            </summary>
            <param name="node">Node</param>
            <returns>Rightmost child of self if no right children</returns>
        </member>
        <member name="T:VDS.Common.Trees.UnbalancedBinaryTree`2">
            <summary>
            An unbalanced binary tree
            </summary>
            <typeparam name="TKey">Key Type</typeparam>
            <typeparam name="TValue">Value Type</typeparam>
        </member>
        <member name="M:VDS.Common.Trees.UnbalancedBinaryTree`2.#ctor">
            <summary>
            Creates a new unbalanced tree
            </summary>
        </member>
        <member name="M:VDS.Common.Trees.UnbalancedBinaryTree`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new unbalanced tree
            </summary>
            <param name="comparer">Key Comparer</param>
        </member>
        <member name="M:VDS.Common.Trees.UnbalancedBinaryTree`2.CreateNode(VDS.Common.Trees.IBinaryTreeNode{`0,`1},`0,`1)">
            <summary>
            Creates a new node
            </summary>
            <param name="parent">Parent</param>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:VDS.Common.Tries.AbstractSparseTrieNode`2">
            <summary>
            Node of a Sparse Trie
            </summary>
            <typeparam name="TKeyBit">Key Bit Type</typeparam>
            <typeparam name="TValue">Value Type</typeparam>
            <remarks>
            </remarks>
        </member>
        <member name="T:VDS.Common.Tries.ITrieNode`2">
            <summary>
            Interface for Trie nodes, this is the node in a <see cref="T:VDS.Common.Tries.ITrie`3"/>
            </summary>
            <typeparam name="TKeyBit">Key Bit Type</typeparam>
            <typeparam name="TValue">Value Type</typeparam>
        </member>
        <member name="M:VDS.Common.Tries.ITrieNode`2.Clear">
            <summary>
            Clears the Value (if any) stored at this node and removes all child nodes
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.ITrieNode`2.ClearValue">
            <summary>
            Clears the Value (if any) stored at this node
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.ITrieNode`2.MoveToChild(`0)">
            <summary>
            Add a child node associated with a key to this node and return the node.
            </summary>
            <param name="key">Key to associated with the child node.</param>
            <returns>If given key already exists then return the existing child node, else return the new child node.</returns>
        </member>
        <member name="M:VDS.Common.Tries.ITrieNode`2.TryGetChild(`0,VDS.Common.Tries.ITrieNode{`0,`1}@)">
            <summary>
            Tries to get a child of this node which is associated with a key bit
            </summary>
            <param name="key">Key</param>
            <param name="child">Child</param>
            <returns>True if a child was found, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Tries.ITrieNode`2.RemoveChild(`0)">
            <summary>
            Remove the child of a node associated with a key along with all its descendents.
            </summary>
            <param name="key">The key associated with the child to remove.</param>
        </member>
        <member name="M:VDS.Common.Tries.ITrieNode`2.Trim">
            <summary>
            Removes all child nodes
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.ITrieNode`2.Trim(System.Int32)">
            <summary>
            Removes all descendant nodes which are at the given depth below the current node
            </summary>
            <param name="depth">Depth</param>
            <exception cref="T:System.ArgumentException">Thrown if depth is less than zero</exception>
        </member>
        <member name="P:VDS.Common.Tries.ITrieNode`2.Descendants">
            <summary>
            Gets all descendants of this Node
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.ITrieNode`2.Children">
            <summary>
            Gets the immediate children of this Node
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.ITrieNode`2.Count">
            <summary>
            Gets the number of immediate child nodes this node has
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.ITrieNode`2.CountAll">
            <summary>
            Gets the number of descendant nodes this node has
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.ITrieNode`2.HasValue">
            <summary>
            Check whether or not this node has a value associated with it
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.ITrieNode`2.IsLeaf">
            <summary>
            Check whether or not this node has any children
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.ITrieNode`2.IsRoot">
            <summary>
            Check whether this Node is the Root Node
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.ITrieNode`2.KeyBit">
            <summary>
            Gets the key bit that is associated with this node
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.ITrieNode`2.Parent">
            <summary>
            Get the parent of this node
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.ITrieNode`2.Value">
            <summary>
            Gets/Sets value stored by this node
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.ITrieNode`2.Values">
            <summary>
            Get an enumerable of values contained in this node and all its descendants
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.AbstractSparseTrieNode`2.#ctor(VDS.Common.Tries.ITrieNode{`0,`1},`0)">
            <summary>
            Create an empty node with no children and null value
            </summary>
            <param name="parent">Parent node of this node</param>
            <param name="key">Key Bit</param>
        </member>
        <member name="M:VDS.Common.Tries.AbstractSparseTrieNode`2.MatchesSingleton(`0)">
            <summary>
            Gets whether the given key bit matches the current singleton
            </summary>
            <param name="key">Key Bit</param>
            <returns>True if it matches, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Tries.AbstractSparseTrieNode`2.CreateNewChild(`0)">
            <summary>
            Creates a new child
            </summary>
            <param name="key">Key</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Tries.AbstractSparseTrieNode`2.ClearSingleton">
            <summary>
            Clears the singelton
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.AbstractSparseTrieNode`2.TryGetChild(`0,VDS.Common.Tries.ITrieNode{`0,`1}@)">
            <summary>
            Tries to get a child of this node which is associated with a key bit
            </summary>
            <param name="key">Key</param>
            <param name="child">Child</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Tries.AbstractSparseTrieNode`2.ClearValue">
            <summary>
            Clears the Value (if any) stored at this node
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.AbstractSparseTrieNode`2.Clear">
            <summary>
            Clears the Value (if any) stored at this node and removes all child nodes
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.AbstractSparseTrieNode`2.Trim">
            <summary>
            Removes all child nodes
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.AbstractSparseTrieNode`2.Trim(System.Int32)">
            <summary>
            Removes all descendant nodes which are at the given depth below the current node
            </summary>
            <param name="depth">Depth</param>
            <exception cref="T:System.ArgumentException">Thrown if depth is less than zero</exception>
        </member>
        <member name="M:VDS.Common.Tries.AbstractSparseTrieNode`2.MoveToChild(`0)">
            <summary>
            Add a child node associated with a key to this node and return the node.
            </summary>
            <param name="key">Key to associated with the child node.</param>
            <returns>If given key already exists then return the existing child node, else return the new child node.</returns>
        </member>
        <member name="M:VDS.Common.Tries.AbstractSparseTrieNode`2.RemoveChild(`0)">
            <summary>
            Remove the child of a node associated with a key along with all its descendents.
            </summary>
            <param name="key">The key associated with the child to remove.</param>
        </member>
        <member name="P:VDS.Common.Tries.AbstractSparseTrieNode`2.SingletonChild">
            <summary>
            Gets/Sets the singleton child node
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.AbstractSparseTrieNode`2.Value">
            <summary>
            Gets/Sets value stored by this node
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.AbstractSparseTrieNode`2.KeyBit">
            <summary>
            Gets the key bit that is associated with this node
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.AbstractSparseTrieNode`2.Parent">
            <summary>
            Get the parent of this node
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.AbstractSparseTrieNode`2.IsRoot">
            <summary>
            Check whether this Node is the Root Node
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.AbstractSparseTrieNode`2.HasValue">
            <summary>
            Check whether or not this node has a value associated with it
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.AbstractSparseTrieNode`2.Count">
            <summary>
            Gets the number of immediate child nodes this node has
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.AbstractSparseTrieNode`2.CountAll">
            <summary>
            Gets the number of descendant nodes this node has
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.AbstractSparseTrieNode`2.IsLeaf">
            <summary>
            Check whether or not this node has any children.
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.AbstractSparseTrieNode`2.Children">
            <summary>
            Gets the immediate children of this Node
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.AbstractSparseTrieNode`2.Descendants">
            <summary>
            Gets all descended children of this Node
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.AbstractSparseTrieNode`2.Values">
            <summary>
            Get an enumerable of values contained in this node and all its descendants
            </summary>
        </member>
        <member name="T:VDS.Common.Tries.AbstractTrie`3">
            <summary>
            An abstract implementation of a Trie
            </summary>
            <typeparam name="TKey">Type of keys</typeparam>
            <typeparam name="TKeyBit">Type of key bits</typeparam>
            <typeparam name="TValue">Type of values</typeparam>
            <remarks>
            <para>
            Keys are converted into a sequence of key bits using a user provided function
            </para>
            <para>
            The original code that inspired this was taken from <a href="http://code.google.com/p/typocalypse/source/browse/#hg/Trie">Typocolypse</a> but has been heavily rewritten to be much more abstract, generic and LINQ friendly
            </para>
            </remarks>
        </member>
        <member name="T:VDS.Common.Tries.ITrie`3">
            <summary>
            Interface for Tries, this is a data structure which maps decomposable keys to values
            </summary>
            <typeparam name="TKey">Key Type</typeparam>
            <typeparam name="TKeyBit">Key Bit Type</typeparam>
            <typeparam name="TValue">Value Type</typeparam>
        </member>
        <member name="M:VDS.Common.Tries.ITrie`3.Add(`0,`2)">
            <summary>
            Adds a new key value pair, overwriting the existing value if the given key is already in use
            </summary>
            <param name="key">Key to search for value by</param>
            <param name="value">Value associated with key</param>
        </member>
        <member name="M:VDS.Common.Tries.ITrie`3.Clear">
            <summary>
            Clears the Trie
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.ITrie`3.Contains(`0,`2)">
            <summary>
            Gets whether the Trie contains the given key value pair
            </summary>
            <param name="key">Key</param>
            <param name="value">Value</param>
            <returns>True if the key value pair exists, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Tries.ITrie`3.ContainsKey(`0)">
            <summary>
            Gets whether the Trie contains a specific key and has a value associated with that key
            </summary>
            <param name="key">Key</param>
            <returns>True if the Trie contains a specific key and has a value associated with it, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Tries.ITrie`3.ContainsKey(`0,System.Boolean)">
            <summary>
            Gets whether the Trie contains a specific key
            </summary>
            <param name="key">Key</param>
            <param name="requireValue">Whether the key is required to have a value associated with it in order to be considered as being contained</param>
            <returns>True if the Trie contains the given key and meets the value requirement</returns>
        </member>
        <member name="M:VDS.Common.Tries.ITrie`3.Find(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Finds and returns a Node for the given sequence of Key Bits
            </summary>
            <param name="bs">Key Bits</param>
            <returns>Null if the Key does not map to a Node</returns>
            <remarks>
            The ability to provide a specific seqeunce of key bits may be useful for custom lookups where you don't necessarily have a value of the <strong>TKey</strong> type but do have values of the <strong>TKeyBit</strong> type
            </remarks>
        </member>
        <member name="M:VDS.Common.Tries.ITrie`3.Find(`0)">
            <summary>
            Finds and returns a Node for the given Key
            </summary>
            <param name="key">Key</param>
            <returns>Null if the Key does not map to a Node</returns>
        </member>
        <member name="M:VDS.Common.Tries.ITrie`3.Find(`0,System.Func{`0,System.Collections.Generic.IEnumerable{`1}})">
            <summary>
            Finds and returns a Node for the given Key using the given Key to Key Bit mapping function
            </summary>
            <param name="key">Key</param>
            <param name="keyMapper">Function to map keys to key bits</param>
            <returns>Null if the Key does not map to a Node</returns>
            <remarks>
            The ability to provide a custom mapping function allows you to do custom lookups into the Trie.  For example you might want to only match some portion of the key rather than the entire key
            </remarks>
        </member>
        <member name="M:VDS.Common.Tries.ITrie`3.FindPredecessor(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Finds and returns a Node that has the longest prefix match for the given sequence of Key Bits
            </summary>
            <param name="bs">Key Bits</param>
            <returns>Null if the Key does not map to a Node</returns>
            <remarks>
            The ability to provide a specific seqeunce of key bits may be useful for custom lookups where you don't necessarily have a value of the <strong>TKey</strong> type but do have values of the <strong>TKeyBit</strong> type
            </remarks>
        </member>
        <member name="M:VDS.Common.Tries.ITrie`3.FindPredecessor(`0)">
            <summary>
            Finds and returns a Node that has the longest prefix match for the given Key
            </summary>
            <param name="key">Key</param>
            <returns>Null if the Key does not map to a Node</returns>
        </member>
        <member name="M:VDS.Common.Tries.ITrie`3.FindPredecessor(`0,System.Func{`0,System.Collections.Generic.IEnumerable{`1}})">
            <summary>
            Finds and returns a Node that has the longest prefix match for the given Key using the given Key to Key Bit mapping function
            </summary>
            <param name="key">Key</param>
            <param name="keyMapper">Function to map keys to key bits</param>
            <returns>Null if the Key does not map to a Node</returns>
            <remarks>
            The ability to provide a custom mapping function allows you to do custom lookups into the Trie.  For example you might want to only match some portion of the key rather than the entire key
            </remarks>
        </member>
        <member name="M:VDS.Common.Tries.ITrie`3.FindSuccessor(`0)">
            <summary>
            Finds and returns a Node that has the shortest prefix match greater than or equal to the given Key
            </summary>
            <param name="key">Key</param>
            <returns>Null if the Key does not map to a Node</returns>
        </member>
        <member name="M:VDS.Common.Tries.ITrie`3.FindSuccessor(`0,System.Func{`0,System.Collections.Generic.IEnumerable{`1}})">
            <summary>
            Finds and returns a Node that has the shortest prefix match greater than or equal to the given Key using the given Key to Key Bit mapping function
            </summary>
            <param name="key">Key</param>
            <param name="keyMapper">Function to map keys to key bits</param>
            <returns>Null if the Key does not map to a Node</returns>
            <remarks>
            The ability to provide a custom mapping function allows you to do custom lookups into the Trie.  For example you might want to only match some portion of the key rather than the entire key
            </remarks>
        </member>
        <member name="M:VDS.Common.Tries.ITrie`3.FindSuccessor(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Finds and returns a Node that has the shortest prefix match greater than or equal to the given sequence of Key Bits
            </summary>
            <param name="bs">Key Bits</param>
            <returns>Null if the Key does not map to a Node</returns>
            <remarks>
            The ability to provide a specific seqeunce of key bits may be useful for custom lookups where you don't necessarily have a value of the <strong>TKey</strong> type but do have values of the <strong>TKeyBit</strong> type
            </remarks>
        </member>
        <member name="M:VDS.Common.Tries.ITrie`3.MoveToNode(`0)">
            <summary>
            Moves to the Node associated with the given Key creating new nodes if necessary
            </summary>
            <param name="key">Key</param>
            <returns>Trie Node</returns>
        </member>
        <member name="M:VDS.Common.Tries.ITrie`3.Remove(`0)">
            <summary>
            Remove the value that a key leads to and any redundant nodes which result from this action
            </summary>
            <param name="key">Key of the value to remove</param>
        </member>
        <member name="M:VDS.Common.Tries.ITrie`3.TryGetValue(`0,`2@)">
            <summary>
            Tries to get the Value associated with a given Key
            </summary>
            <param name="key">Key</param>
            <param name="value">Value, may be null if the key exists but has no value associated with it</param>
            <returns>True if the Key exists in the Trie, False if it does not</returns>
        </member>
        <member name="P:VDS.Common.Tries.ITrie`3.Count">
            <summary>
            Gets the Count of all Nodes in the Trie
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.ITrie`3.Root">
            <summary>
            Gets the Root Node of the Trie
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.ITrie`3.Item(`0)">
            <summary>
            Gets/Sets the Value associated with a given Key
            </summary>
            <param name="key">Key</param>
            <returns>Value associated with the given Key, may be null if no value is associated</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if you try to get a value for a key that is not in the Trie</exception>
        </member>
        <member name="P:VDS.Common.Tries.ITrie`3.Values">
            <summary>
            Gets all the Values in the Trie
            </summary>
        </member>
        <member name="F:VDS.Common.Tries.AbstractTrie`3._keyMapper">
            <summary>
            Key Mapper function
            </summary>
        </member>
        <member name="F:VDS.Common.Tries.AbstractTrie`3._root">
            <summary>
            Root of the Trie
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.AbstractTrie`3.#ctor(System.Func{`0,System.Collections.Generic.IEnumerable{`1}})">
            <summary>
            Create an empty trie with an empty root node.
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.AbstractTrie`3.CreateRoot(`1)">
            <summary>
            Method which creates a new child node
            </summary>
            <param name="key">Key Bit</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Tries.AbstractTrie`3.Add(`0,`2)">
            <summary>
            Adds a new key value pair, overwriting the existing value if the given key is already in use
            </summary>
            <param name="key">Key to search for value by</param>
            <param name="value">Value associated with key</param>
        </member>
        <member name="M:VDS.Common.Tries.AbstractTrie`3.Remove(`0)">
            <summary>
            Remove the value that a key leads to and any redundant nodes which result from this action
            </summary>
            <param name="key">Key of the value to remove</param>
        </member>
        <member name="M:VDS.Common.Tries.AbstractTrie`3.Contains(`0,`2)">
            <summary>
            Gets whether the Trie contains the given key value pair
            </summary>
            <param name="key">Key</param>
            <param name="value">Value</param>
            <returns>True if the key value pair exists, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Tries.AbstractTrie`3.ContainsKey(`0)">
            <summary>
            Gets whether the Trie contains a specific key and has a value associated with that key
            </summary>
            <param name="key">Key</param>
            <returns>True if the Trie contains a specific key and has a value associated with it, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Tries.AbstractTrie`3.ContainsKey(`0,System.Boolean)">
            <summary>
            Gets whether the Trie contains a specific key
            </summary>
            <param name="key">Key</param>
            <param name="requireValue">Whether the key is required to have a value associated with it in order to be considered as being contained</param>
            <returns>True if the Trie contains the given key and meets the value requirement</returns>
        </member>
        <member name="M:VDS.Common.Tries.AbstractTrie`3.Find(`0)">
            <summary>
            Finds and returns a Node for the given Key
            </summary>
            <param name="key">Key</param>
            <returns>Null if the Key does not map to a Node</returns>
        </member>
        <member name="M:VDS.Common.Tries.AbstractTrie`3.Find(`0,System.Func{`0,System.Collections.Generic.IEnumerable{`1}})">
            <summary>
            Finds and returns a Node for the given Key using the given Key to Key Bit mapping function
            </summary>
            <param name="key">Key</param>
            <param name="keyMapper">Function to map keys to key bits</param>
            <returns>Null if the Key does not map to a Node</returns>
            <remarks>
            The ability to provide a custom mapping function allows you to do custom lookups into the Trie.  For example you might want to only match some portion of the key rather than the entire key
            </remarks>
        </member>
        <member name="M:VDS.Common.Tries.AbstractTrie`3.Find(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Finds and returns a Node for the given sequence of Key Bits
            </summary>
            <param name="bs">Key Bits</param>
            <returns>Null if the Key does not map to a Node</returns>
            <remarks>
            The ability to provide a specific sequence of key bits may be useful for custom lookups where you don't necessarily have a value of the <strong>TKey</strong> type but do have values of the <strong>TKeyBit</strong> type
            </remarks>
        </member>
        <member name="M:VDS.Common.Tries.AbstractTrie`3.FindPredecessor(`0)">
            <summary>
            Finds and returns a Node that has the longest prefix match for the given sequence of Key Bits
            </summary>
            <param name="key">Key</param>
            <returns>Null if the Key does not map to any nodes</returns>
        </member>
        <member name="M:VDS.Common.Tries.AbstractTrie`3.FindPredecessor(`0,System.Func{`0,System.Collections.Generic.IEnumerable{`1}})">
            <summary>
            Finds and returns a Node that has the longest prefix match for the given Key
            </summary>
            <param name="key">Key</param>
            <param name="keyMapper">Mapper that decomposes the key into the key bits</param>
            <returns>Null if the Key does not map to a Node</returns>
            <remarks>
            The ability to provide a custom mapping function allows you to do custom lookups into the Trie.  For example you might want to only match some portion of the key rather than the entire key
            </remarks>
        </member>
        <member name="M:VDS.Common.Tries.AbstractTrie`3.FindPredecessor(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Finds and returns a Node that has the longest prefix match for the given Key using the given Key to Key Bit mapping function
            </summary>
            <param name="bs">Key bits</param>
            <returns>Null if the Key does not map to a Node</returns>
            <remarks>
            The ability to provide a specific sequence of key bits may be useful for custom lookups where you don't necessarily have a value of the <strong>TKey</strong> type but do have values of the <strong>TKeyBit</strong> type
            </remarks>
        </member>
        <member name="M:VDS.Common.Tries.AbstractTrie`3.FindSuccessor(`0)">
            <summary>
            Finds and returns a Node that has the shortest prefix match greater than or equal to the given sequence of Key Bits
            </summary>
            <param name="key">Key</param>
            <returns>Null if the Key does not map to a Node</returns>
        </member>
        <member name="M:VDS.Common.Tries.AbstractTrie`3.FindSuccessor(`0,System.Func{`0,System.Collections.Generic.IEnumerable{`1}})">
            <summary>
            Finds and returns a Node that has the shortest prefix match greater than or equal to the given Key
            </summary>
            <param name="key">Key</param>
            <param name="keyMapper">Mapper that decomposes the key into the key bits</param>
            <returns>Null if the Key does not map to a Node</returns>
            <remarks>
            The ability to provide a custom mapping function allows you to do custom lookups into the Trie.  For example you might want to only match some portion of the key rather than the entire key
            </remarks>
        </member>
        <member name="M:VDS.Common.Tries.AbstractTrie`3.FindSuccessor(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Finds and returns a Node that has the shortest prefix match greater than or equal to the given Key using the given Key to Key Bit mapping function
            </summary>
            <param name="bs">Key Bits</param>
            <returns>Null if the Key does not map to a Node</returns>
            <remarks>
            The ability to provide a specific sequence of key bits may be useful for custom lookups where you don't necessarily have a value of the <strong>TKey</strong> type but do have values of the <strong>TKeyBit</strong> type
            </remarks>
        </member>
        <member name="M:VDS.Common.Tries.AbstractTrie`3.MoveToNode(`0)">
            <summary>
            Moves to the Node associated with the given Key creating new nodes if necessary
            </summary>
            <param name="key">Key</param>
            <returns>Trie Node</returns>
        </member>
        <member name="M:VDS.Common.Tries.AbstractTrie`3.TryGetValue(`0,`2@)">
            <summary>
            Tries to get the Value associated with a given Key
            </summary>
            <param name="key">Key</param>
            <param name="value">Value, will be null if the key does not exist or has no value associated with it</param>
            <returns>True if the Key exists in the Trie and has a value associated with it, False if it does not</returns>
        </member>
        <member name="M:VDS.Common.Tries.AbstractTrie`3.Clear">
            <summary>
            Clears the Trie
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.AbstractTrie`3.Root">
            <summary>
            Gets the Root Node of the Trie
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.AbstractTrie`3.KeyBitComparer">
            <summary>
            Key comparer used for ordered operations like FindSuccessor
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.AbstractTrie`3.Item(`0)">
            <summary>
            Gets/Sets the Value associated with a given Key
            </summary>
            <param name="key">Key</param>
            <returns>Value associated with the given Key, may be null if no value is associated</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if you try to get a value for a key that is not in the Trie</exception>
        </member>
        <member name="P:VDS.Common.Tries.AbstractTrie`3.Count">
            <summary>
            Gets the Count of all Nodes in the Trie
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.AbstractTrie`3.Values">
            <summary>
            Gets all the Values in the Trie
            </summary>
        </member>
        <member name="T:VDS.Common.Tries.DescendantNodesEnumerable`2">
            <summary>
            An enumerable over a Trie which ensures every time it is enumerated the latest state of the Trie is seen
            </summary>
            <typeparam name="TKeyBit">Key Bit Type</typeparam>
            <typeparam name="TValue">Valye Type</typeparam>
        </member>
        <member name="M:VDS.Common.Tries.DescendantNodesEnumerable`2.#ctor(VDS.Common.Tries.ITrieNode{`0,`1})">
            <summary>
            Creates a descendant nodes enumable
            </summary>
            <param name="node">Node</param>
        </member>
        <member name="M:VDS.Common.Tries.DescendantNodesEnumerable`2.GetEnumerator">
            <summary>
            Gets the enumerator over the descendants
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Tries.DescendantNodesEnumerable`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets the enumerator over the descendants
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.Common.Tries.TrieValuesEnumerable`2">
            <summary>
            An enumerable over the values of a Trie which ensures that the latest state of the Trie is always enumerated
            </summary>
            <typeparam name="TKeyBit">Key Bit Type</typeparam>
            <typeparam name="TValue">Valye Type</typeparam>
        </member>
        <member name="M:VDS.Common.Tries.TrieValuesEnumerable`2.#ctor(VDS.Common.Tries.ITrieNode{`0,`1})">
            <summary>
            Creates a new values enumerator
            </summary>
            <param name="node">Node to start enumeration from</param>
        </member>
        <member name="M:VDS.Common.Tries.TrieValuesEnumerable`2.GetEnumerator">
            <summary>
            Gets an enumerator over the values in the Trie
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Tries.TrieValuesEnumerable`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator over the values in the Trie
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.Common.Tries.SparseValueTrie`3">
            <summary>
            Sparse implementation of a Trie data structure
            </summary>
            <typeparam name="TKey">Type of keys</typeparam>
            <typeparam name="TKeyBit">Type of key bits</typeparam>
            <typeparam name="TValue">Type of values</typeparam>
            <remarks>
            </remarks>
        </member>
        <member name="M:VDS.Common.Tries.SparseValueTrie`3.#ctor(System.Func{`0,System.Collections.Generic.IEnumerable{`1}})">
            <summary>
            Create an empty trie with an empty root node.
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.SparseValueTrie`3.CreateRoot(`1)">
            <summary>
            Method which creates a new child node
            </summary>
            <param name="key">Key Bit</param>
            <returns></returns>
        </member>
        <member name="T:VDS.Common.Tries.SparseReferenceTrie`3">
            <summary>
            Sparse implementation of a Trie data structure
            </summary>
            <typeparam name="TKey">Type of keys</typeparam>
            <typeparam name="TKeyBit">Type of key bits</typeparam>
            <typeparam name="TValue">Type of values</typeparam>
            <remarks>
            </remarks>
        </member>
        <member name="M:VDS.Common.Tries.SparseReferenceTrie`3.#ctor(System.Func{`0,System.Collections.Generic.IEnumerable{`1}})">
            <summary>
            Create an empty trie with an empty root node.
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.SparseReferenceTrie`3.CreateRoot(`1)">
            <summary>
            Method which creates a new child node
            </summary>
            <param name="key">Key Bit</param>
            <returns></returns>
        </member>
        <member name="T:VDS.Common.Tries.SparseCharacterTrie`2">
            <summary>
            Sparse Implementation of a Trie data structure optimized for the common case of the key bits being characters
            </summary>
            <typeparam name="TKey">Type of keys</typeparam>
            <typeparam name="TValue">Type of values</typeparam>
        </member>
        <member name="M:VDS.Common.Tries.SparseCharacterTrie`2.#ctor(System.Func{`0,System.Collections.Generic.IEnumerable{System.Char}})">
            <summary>
            Creates a new sparse character trie
            </summary>
            <param name="keyMapper">Key Mapper</param>
        </member>
        <member name="M:VDS.Common.Tries.SparseCharacterTrie`2.CreateRoot(System.Char)">
            <summary>
            Creates the root node of the trie
            </summary>
            <param name="key">Key</param>
            <returns>Root Node</returns>
        </member>
        <member name="T:VDS.Common.Tries.SparseValueTrieNode`2">
            <summary>
            Sparse Node of a Trie
            </summary>
            <typeparam name="TKeyBit">Key Bit Type</typeparam>
            <typeparam name="TValue">Value Type</typeparam>
        </member>
        <member name="M:VDS.Common.Tries.SparseValueTrieNode`2.#ctor(VDS.Common.Tries.ITrieNode{`0,`1},`0)">
            <summary>
            Create an empty node with no children and null value
            </summary>
            <param name="parent">Parent node of this node</param>
            <param name="key">Key Bit</param>
        </member>
        <member name="M:VDS.Common.Tries.SparseValueTrieNode`2.MatchesSingleton(`0)">
            <summary>
            Gets whether the given key bit matches the current singleton
            </summary>
            <param name="key">Key Bit</param>
            <returns>True if it matches, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Tries.SparseValueTrieNode`2.ClearSingleton">
            <summary>
            Clears the singleton
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.SparseValueTrieNode`2.CreateNewChild(`0)">
            <summary>
            Creates a new child in the trie
            </summary>
            <param name="key">Key Bit</param>
            <returns>New Child</returns>
        </member>
        <member name="P:VDS.Common.Tries.SparseValueTrieNode`2.SingletonChild">
            <summary>
            Gets/Sets the singleton child node
            </summary>
        </member>
        <member name="T:VDS.Common.Tries.SparseReferenceTrieNode`2">
            <summary>
            Sparse Node of a Trie
            </summary>
            <typeparam name="TKeyBit">Key Bit Type</typeparam>
            <typeparam name="TValue">Value Type</typeparam>
        </member>
        <member name="M:VDS.Common.Tries.SparseReferenceTrieNode`2.#ctor(VDS.Common.Tries.ITrieNode{`0,`1},`0)">
            <summary>
            Create an empty node with no children and null value
            </summary>
            <param name="parent">Parent node of this node</param>
            <param name="key">Key Bit</param>
        </member>
        <member name="M:VDS.Common.Tries.SparseReferenceTrieNode`2.MatchesSingleton(`0)">
            <summary>
            Gets whether the key matches the singleton
            </summary>
            <param name="key">Key Bit</param>
            <returns>True if it matches, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Tries.SparseReferenceTrieNode`2.ClearSingleton">
            <summary>
            Clears the singleton
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.SparseReferenceTrieNode`2.CreateNewChild(`0)">
            <summary>
            Creates a new child node
            </summary>
            <param name="key">Key Bit</param>
            <returns>New Child</returns>
        </member>
        <member name="P:VDS.Common.Tries.SparseReferenceTrieNode`2.SingletonChild">
            <summary>
            Gets/Sets the singleton child
            </summary>
        </member>
        <member name="T:VDS.Common.Tries.SparseCharacterTrieNode`1">
            <summary>
            Sparse Node of a Trie
            </summary>
            <typeparam name="TValue">Value Type</typeparam>
        </member>
        <member name="M:VDS.Common.Tries.SparseCharacterTrieNode`1.#ctor(VDS.Common.Tries.ITrieNode{System.Char,`0},System.Char)">
            <summary>
            Creates a new Sparse Character Trie Node
            </summary>
            <param name="parent">Parent Node</param>
            <param name="key">Key Bit</param>
        </member>
        <member name="M:VDS.Common.Tries.SparseCharacterTrieNode`1.MatchesSingleton(System.Char)">
            <summary>
            Gets whether the given key matches the singleton
            </summary>
            <param name="key">Key Bit</param>
            <returns>True if it matches, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Tries.SparseCharacterTrieNode`1.ClearSingleton">
            <summary>
            Clears the singleton
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.SparseCharacterTrieNode`1.CreateNewChild(System.Char)">
            <summary>
            Creates a new child
            </summary>
            <param name="key">Key Bit</param>
            <returns>New Child</returns>
        </member>
        <member name="P:VDS.Common.Tries.SparseCharacterTrieNode`1.SingletonChild">
            <summary>
            Gets/Sets the singleton child
            </summary>
        </member>
        <member name="T:VDS.Common.Tries.StringTrie`1">
            <summary>
            Represents the classic use case of a Trie data structure, keys are strings with a character stored at each Node
            </summary>
            <typeparam name="T">Type of values to be stored</typeparam>
        </member>
        <member name="T:VDS.Common.Tries.Trie`3">
            <summary>
            Standard implementation of a Trie data structure
            </summary>
            <typeparam name="TKey">Type of keys</typeparam>
            <typeparam name="TKeyBit">Type of key bits</typeparam>
            <typeparam name="TValue">Type of values</typeparam>
            <remarks>
            </remarks>
        </member>
        <member name="M:VDS.Common.Tries.Trie`3.#ctor(System.Func{`0,System.Collections.Generic.IEnumerable{`1}})">
            <summary>
            Create an empty trie with an empty root node.
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.Trie`3.CreateRoot(`1)">
            <summary>
            Method which creates a new child node
            </summary>
            <param name="key">Key Bit</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Tries.StringTrie`1.#ctor">
            <summary>
            Creates a new String Trie
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.StringTrie`1.KeyMapper(System.String)">
            <summary>
            Key Mapper function for String Trie
            </summary>
            <param name="key">Key</param>
            <returns>Array of characters</returns>
        </member>
        <member name="T:VDS.Common.Tries.SparseStringTrie`1">
            <summary>
            Represents the classic use case of a Trie data structure, keys are strings with a character stored at each Node
            </summary>
            <typeparam name="T">Type of values to be stored</typeparam>
            <remarks>
            This is a sparse implementation so should be more memory efficient than the <see cref="T:VDS.Common.Tries.StringTrie`1"/> for many use cases
            </remarks>
        </member>
        <member name="M:VDS.Common.Tries.SparseStringTrie`1.#ctor">
            <summary>
            Creates a new sparse String Trie
            </summary>
        </member>
        <member name="T:VDS.Common.Tries.TrieNode`2">
            <summary>
            Node of a Trie
            </summary>
            <typeparam name="TKeyBit">Key Bit Type</typeparam>
            <typeparam name="TValue">Value Type</typeparam>
            <remarks>
            <para>
            Original code taken from <a href="http://code.google.com/p/typocalypse/source/browse/#hg/Trie">Typocolypse</a> but has been heavily rewritten to be much more generic and LINQ friendly
            </para>
            </remarks>
        </member>
        <member name="M:VDS.Common.Tries.TrieNode`2.#ctor(VDS.Common.Tries.ITrieNode{`0,`1},`0)">
            <summary>
            Create an empty node with no children and null value
            </summary>
            <param name="parent">Parent node of this node</param>
            <param name="key">Key Bit</param>
        </member>
        <member name="M:VDS.Common.Tries.TrieNode`2.EnterReadLock">
            <summary>
            Enters a read lock on this node
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.TrieNode`2.ExitReadLock">
            <summary>
            Exits a read lock on this node
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.TrieNode`2.EnterUpgradeableReadLock">
            <summary>
            Enters an upgradeable read lock on this node
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.TrieNode`2.ExitUpgradeableReadLock">
            <summary>
            Exits an upgradeable read lock on this node
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.TrieNode`2.EnterWriteLock">
            <summary>
            Enters a write lock on this node
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.TrieNode`2.ExitWriteLock">
            <summary>
            Exits a write lock on this node
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.TrieNode`2.GetChild(`0)">
            <summary>
            Get a child of this node which is associated with a key bit
            </summary>
            <param name="key">Key associated with the child of interest</param>
            <returns>The child or null if no child is associated with the given key</returns>
        </member>
        <member name="M:VDS.Common.Tries.TrieNode`2.TryGetChild(`0,VDS.Common.Tries.ITrieNode{`0,`1}@)">
            <summary>
            Tries to get a child of this node which is associated with a key bit
            </summary>
            <param name="key">Key</param>
            <param name="child">Child</param>
            <returns></returns>
        </member>
        <member name="M:VDS.Common.Tries.TrieNode`2.ContainsKey(`0)">
            <summary>
            Check whether or not one of the children of this node uses the given key bit
            </summary>
            <param name="key">The key bit to check for</param>
            <returns>True if a child with given key exists, false otherwise</returns>
        </member>
        <member name="M:VDS.Common.Tries.TrieNode`2.ClearValue">
            <summary>
            Clears the Value (if any) stored at this node
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.TrieNode`2.Clear">
            <summary>
            Clears the Value (if any) stored at this node and removes all child nodes
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.TrieNode`2.Trim">
            <summary>
            Removes all child nodes
            </summary>
        </member>
        <member name="M:VDS.Common.Tries.TrieNode`2.Trim(System.Int32)">
            <summary>
            Removes all descendant nodes which are at the given depth below the current node
            </summary>
            <param name="depth">Depth</param>
            <exception cref="T:System.ArgumentException">Thrown if depth is less than zero</exception>
        </member>
        <member name="M:VDS.Common.Tries.TrieNode`2.MoveToChild(`0)">
            <summary>
            Add a child node associated with a key to this node and return the node.
            </summary>
            <param name="key">Key to associated with the child node.</param>
            <returns>If given key already exists then return the existing child node, else return the new child node.</returns>
        </member>
        <member name="M:VDS.Common.Tries.TrieNode`2.RemoveChild(`0)">
            <summary>
            Remove the child of a node associated with a key along with all its descendents.
            </summary>
            <param name="key">The key associated with the child to remove.</param>
        </member>
        <member name="P:VDS.Common.Tries.TrieNode`2.Value">
            <summary>
            Gets/Sets value stored by this node
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.TrieNode`2.KeyBit">
            <summary>
            Gets the key bit that is associated with this node
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.TrieNode`2.Parent">
            <summary>
            Get the parent of this node
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.TrieNode`2.IsRoot">
            <summary>
            Check whether this Node is the Root Node
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.TrieNode`2.HasValue">
            <summary>
            Check whether or not this node has a value associated with it
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.TrieNode`2.Count">
            <summary>
            Gets the number of immediate child nodes this node has
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.TrieNode`2.CountAll">
            <summary>
            Gets the number of descendant nodes this node has
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.TrieNode`2.IsLeaf">
            <summary>
            Check whether or not this node has any children.
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.TrieNode`2.Children">
            <summary>
            Gets the immediate children of this Node
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.TrieNode`2.Descendants">
            <summary>
            Gets all descended children of this Node
            </summary>
        </member>
        <member name="P:VDS.Common.Tries.TrieNode`2.Values">
            <summary>
            Get an enumerable of values contained in this node and all its descendants
            </summary>
        </member>
    </members>
</doc>
